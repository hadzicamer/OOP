// DLWMS reminder

//#include<iostream>
//#include<vector>
//#include<string>
//#include<regex>
//using namespace std;
//
//const char* crt = "\n-----------------------------------\n";
//
//class Datum {
//	int* _dan, * _mjesec, * _godina;
//public:
//	Datum(int dan = 1, int mjesec = 1, int godina = 2000) {
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//	}
//	Datum(const Datum& dat) {
//		_dan = new int(*dat._dan);
//		_mjesec = new int(*dat._mjesec);
//		_godina = new int(*dat._godina);
//	}
//	~Datum() {
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//	}
//	friend ostream& operator<<(ostream& COUT, const Datum& obj) {
//		COUT << *obj._dan << " " << *obj._mjesec << " " << *obj._godina;
//		return COUT;
//	}
//
//	void operator=(const Datum& dat) {
//		if (this != &dat) {
//			*_dan = *dat._dan;
//			* _mjesec = *dat._mjesec;
//			* _godina = *dat._godina;
//		}
//	}
//
//};
//class Izuzetak : public exception {
//	string _funkcija;
//	// u ovoj klasi nije bio implementiran konstruktor, potrebno je primjetit da exception nasljeduje poruku i string parametar izjednacit 
//public:
//	Izuzetak(const char* poruka, string funkcija) :exception(poruka),_funkcija(funkcija) {}
//	friend ostream& operator<<(ostream& COUT, const Izuzetak &exc) {
//		COUT << exc.what() << endl;
//		COUT << "Funkcija: " << exc._funkcija << endl;
//		return COUT;
//	}
//};
//
//template <class T1, class T2>
//class Kolekcija {
//	T1* _elementi1;
//	T2* _elementi2;
//	int _trenutnoElemenata;
//	bool _omoguciDupliranjeElemenata;
//public:
//	Kolekcija(bool omoguciDupliranjeElemenata = false) {
//		_trenutnoElemenata = 0;
//		_omoguciDupliranjeElemenata = omoguciDupliranjeElemenata;
//		_elementi1 = nullptr;
//		_elementi2 = nullptr;
//	}
//
//	Kolekcija(const Kolekcija& kol) {
//		_omoguciDupliranjeElemenata = kol._omoguciDupliranjeElemenata;
//		_trenutnoElemenata = kol._trenutnoElemenata;
//		_elementi1 = new T1[kol._trenutnoElemenata];
//		_elementi2 = new T2[kol._trenutnoElemenata];
//		for (size_t i = 0; i < kol._trenutnoElemenata; i++)
//		{
//			_elementi1[i] = kol._elementi1[i];
//			_elementi2[i] = kol._elementi2[i];
//		}
//	}
//
//	~Kolekcija() {
//		delete[]_elementi2; _elementi2 = nullptr;
//		delete[]_elementi1; _elementi1 = nullptr;
//		_trenutnoElemenata = 0;
//	}
//
//	int GetTrenutno() const { return _trenutnoElemenata; }
//
//	void SetElement2(int lokacija, T2 el2)const {
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw Izuzetak("Nepostojeca lokacija", __FUNCTION__);
//		_elementi2[lokacija]=el2;
//	}
//
//	T1& GetElement1(int lokacija) const
//	{
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw Izuzetak("Nepostojeca lokacija", __FUNCTION__);
//		return _elementi1[lokacija];
//	}
//
//	T2& GetElement2(int lokacija) const
//	{
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw Izuzetak("Nepostojeca lokacija", __FUNCTION__);
//		return _elementi2[lokacija];
//	}
//
//	friend ostream& operator<<(ostream& COUT, const Kolekcija& obj) {
//		for (size_t i = 0; i < obj.GetTrenutno(); i++)
//			COUT << obj._elementi1[i] << " " << obj._elementi2[i] << endl;
//		return COUT;
//	}
//
//	bool AddElement(T1 el1, T2 el2) {
//		if (!_omoguciDupliranjeElemenata) {
//			for (size_t i = 0; i < _trenutnoElemenata; i++)
//			{
//				if (_elementi1[i] == el1 && _elementi2[i] == el2) // ako su elementi jednaki da se ne dodaju
//					return false;
//			}
//		}
//		T1* temp1 = new T1[_trenutnoElemenata + 1];
//		T2* temp2 = new T2[_trenutnoElemenata + 1];
//
//		for (size_t i = 0; i < _trenutnoElemenata; i++)
//		{
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//		delete[]_elementi1; 
//		delete[]_elementi2; 
//		temp1[_trenutnoElemenata] = el1;
//		temp2[_trenutnoElemenata] = el2;
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//		_trenutnoElemenata++;
//		return true;
//	}
//
//	void operator=(const Kolekcija& kol) {
//		if (this != &kol) {
//			delete[]_elementi1; delete[]_elementi2;
//			_omoguciDupliranjeElemenata = kol._omoguciDupliranjeElemenata;
//			_trenutnoElemenata = kol._trenutnoElemenata;
//			_elementi1 = new T1[kol._trenutnoElemenata];
//			_elementi2 = new T2[kol._trenutnoElemenata];
//			for (size_t i = 0; i < kol._trenutnoElemenata; i++)
//			{
//				_elementi1[i] = kol._elementi1[i];
//				_elementi2[i] = kol._elementi2[i];
//			}
//		}
//	}
//
//	bool RemoveElement(T1 el1) {
//		int indeks = -1;
//		for (size_t i = 0; i < _trenutnoElemenata; i++)
//		{
//			if (_elementi1[i] == el1)
//				indeks = i;
//		}
//		if (indeks == -1)
//			return false;
//		for (size_t i = indeks; i < _trenutnoElemenata-1; i++)
//		{
//			_elementi1[i] = _elementi1[i + 1];
//			_elementi2[i] = _elementi2[i + 1];
//		}
//		_trenutnoElemenata--;
//		return true;
//	}
//};
//
//class Dogadjaj
//{
//	Datum _datumOdrzavanja;
//	Kolekcija<string, bool>* _obaveze; //cuva informaciju o obavezama koje je potrebno ispuniti prije samog dogadjaja, string se odnosi na opis, a bool na izvrsenje te obaveze (da li je zavrsena ili ne)
//
//	char* _naziv;
//	int _notificirajPrije; //oznacava broj dana prije samog dogadjaja kada ce krenuti notifikacija/podsjetnik
//	bool _rekurzivnaNotifikacija; //ako je vrijednost true onda se korisnik notificira svaki dan do _datumaOdrzavanja dogadjaja, a pocevsi prije dogadjaja za _brojDanaZaNotifikaciju
//	bool validnost(string pravilo) {
//		return regex_search(pravilo, regex("pokusati|probati|izvesti"));
//	}
//public:
//	Dogadjaj(Datum datumOdrzavanja, const char* naziv, int brojDana = 1,
//		bool rekurzivnaNotifikacija = false) : _datumOdrzavanja(datumOdrzavanja)
//	{
//		_naziv = new char[strlen(naziv) + 1];
//		strcpy_s(_naziv, strlen(naziv) + 1, naziv);
//
//		_notificirajPrije = brojDana;
//		_rekurzivnaNotifikacija = rekurzivnaNotifikacija;
//		_obaveze = nullptr;
//	}
//
//	Dogadjaj(const Dogadjaj& obj) : _datumOdrzavanja(obj._datumOdrzavanja)
//	{
//		_naziv = new char[strlen(obj._naziv) + 1];
//		strcpy_s(_naziv, strlen(obj._naziv) + 1, obj._naziv);
//
//		_notificirajPrije = obj._notificirajPrije;
//		_rekurzivnaNotifikacija = obj._rekurzivnaNotifikacija;
//		// obaveze su bile inicijalizovane kao pokazivac a samo je dodijeljena vrijednost tako da ce program pucat ako ne napravimo ovo 2 ispod
//		_obaveze = new Kolekcija<string,bool>;
//		*_obaveze = *obj._obaveze;
//	}
//	~Dogadjaj()
//	{
//		delete[] _naziv;
//		_naziv = nullptr;
//		delete _obaveze;
//		_obaveze = nullptr;
//	}
//	char* GetNaziv() { return _naziv; }
//	Kolekcija<string, bool>* GetObaveze() { return _obaveze; }
//
//	bool AddObavezu(string obaveza) {
//	
//		if (_obaveze == nullptr)
//			_obaveze = new Kolekcija<string, bool>;
//		if (validnost(obaveza))
//			throw Izuzetak("Postoji zabranjena rijec!", __FUNCTION__);
//		return _obaveze->AddElement(obaveza, false);
//	}
//
//	friend bool operator==(const Dogadjaj&, const Dogadjaj&);
//};
// 
//bool operator==(const Dogadjaj& dog1, const Dogadjaj& dog2) {
//	return strcmp(dog1._naziv, dog2._naziv) == 0;
//}
//
//
//class Student
//{
//	int _indeks;
//	string _imePrezime;
//	vector<Dogadjaj> _dogadjaji;
//public:
//
//	Student(int indeks, string imePrezime) : _indeks(indeks), _imePrezime(imePrezime) {}
//
//	int GetIndeks() const { return _indeks; }
//
//	vector<Dogadjaj>& GetDogadjaji() { return _dogadjaji; }
//
//	friend ostream& operator<<(ostream& COUT, const Student& obj)
//	{
//		COUT << obj._imePrezime << " (" << obj._indeks << ")" << endl;
//		return COUT;
//	}
//
//	bool AddDogadjaj(const Dogadjaj& dog) {
//		for (size_t i = 0; i < _dogadjaji.size(); i++)
//		{
//			if (_dogadjaji[i] == dog)
//				return false;
//		}
//		_dogadjaji.push_back(dog);
//		return true;
//	}
//};
//
//class DLWMSReminder
//{
//	vector<Student> _reminiderList;
//public:
//	void AddStudent(const Student &stud) {
//		for (vector<Student>::iterator i = _reminiderList.begin(); i != _reminiderList.end(); i++) {
//			if (i->GetIndeks() == stud.GetIndeks()) // da smo isli obicnom petljom reminderList[i]
//				throw Izuzetak("Student sa tim brojem indeksa vec postoji", __FUNCTION__);
//	}
//		_reminiderList.push_back(stud);
//	}
//
//	bool OznaciObavezuKaoZavrsenu(int index, string dogadjaj, string obaveza) {
//	
//		for (vector<Student>::iterator i = _reminiderList.begin(); i !=_reminiderList.end(); i++)
//		{
//			if (i->GetIndeks() == index) {
//				for (vector<Dogadjaj>::iterator j = i->GetDogadjaji().begin(); j < i->GetDogadjaji().end(); j++)
//				{
//					if (j->GetNaziv() == dogadjaj && j->GetObaveze() != nullptr) {
//						for (size_t k = 0; k < j->GetObaveze()->GetTrenutno(); k++)
//						{
//							if (j->GetObaveze()->GetElement1(k) == obaveza) {
//								j->GetObaveze()->SetElement2(k, true);
//								return true;
//							}
//
//						}
//					}
//
//				}
//			}
//
//		}
//		return false;
//	}
//};
//
//void main() {
//
//	/**************************************************************************
//	1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR CE BITI OZNACENO KAO "RE"
//	3. SPASAVAJTE PROJEKAT KAKO BI SE SPRIJECILO GUBLJENJE URADJENOG ZADATKA
//	4. PROGRAMSKI CODE SE TAKODJER NALAZI U FAJLU CODE_ParcijalniII.TXT
//	5. NAZIVI FUNKCIJA MORAJU BITI IDENTIČNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U.OSTALE, POMOĆNE FUNKCIJE MOŽETE IMENOVATI PO ŽELJI.
//	****************************************************************************/
//
//#pragma region Datum
//
//	Datum danas(28, 1, 2018), sutra(29, 1, 2018);
//	Datum datumIspitaPRIII(30, 1, 2018), datumIspitBPII(31, 1, 2018);
//	Datum prekosutra(danas); //poziv konstruktora kopije(prekosutra se kreira na osnovu danas) (vec implementiran)
//	prekosutra = danas; // operator dodjele
//	cout << danas << endl // operaotor ispisa(vec implementiran)
//		<< sutra << endl
//		<< prekosutra << crt;
//
//#pragma endregion
//
////#pragma region Kolekcija
//
//	/*
//	AddElement :: omogucava dodavanje novog elementa u kolekciju. 
//	Ukoliko je moguce, osigurati automatsko prosiranje kolekcije prilikom dodavanja svakog novog elementa, 
//	te onemoguciti ponavljanje elemenata
//	RemoveElement :: na osnovu parametra tipa T1 uklanja elemente iz kolekcije i 
//	ukoliko je moguce smanjuje velicinu niza/kolekcije. Prilikom uklanjanja elemenata ocuvati redoslijed njihovog dodavanja
//	*/
//
//	const int brElemenata = 10;
//	Kolekcija<int, float> kolekcija1;
//	for (size_t i = 0; i < brElemenata; i++)
//		if (!kolekcija1.AddElement(i, i + (0.6 * i)))
//			cout << "Elementi " << i << " i " << i + (0.6 * i) << " nisu dodati u kolekciju" << endl;
//
//	cout << kolekcija1.GetElement1(0) << " " << kolekcija1.GetElement2(0) << endl;
//	cout << kolekcija1 << endl;
//
//	kolekcija1.RemoveElement(1);
//
//	Kolekcija<int, float> kolekcija2;
//	kolekcija2 = kolekcija1; // operator dodjele
//	cout << kolekcija2 << crt;
//
//	if (kolekcija1.GetTrenutno() == kolekcija2.GetTrenutno())
//		cout << "ISTI BROJ ELEMENATA" << endl;
//
//	Kolekcija<int, float> kolekcija3(kolekcija2); // konstruktor kopije
//	cout << kolekcija3 << crt;
//
//#pragma endregion
//
//#pragma region Dogadjaj
//
//	Dogadjaj ispitPRIII(datumIspitaPRIII, "Ispit iz PRIII", 5, true),
//		ispitBPII(datumIspitBPII, "Ispit iz BPII", 7, true);
//	/*po vlasitom izboru definisati listu zabranjenih rijeci koje ce onemoguciti dodavanje odredjene obaveze. 
//	Prilikom provjere koristiti regex*/
//	if (ispitPRIII.AddObavezu("Preraditi pdf materijale"))cout << "Obaveza dodana!" << endl;
//	//onemoguciti dupliranje obaveza
//	if (!ispitPRIII.AddObavezu("Preraditi pdf materijale"))cout << "Obaveza nije dodana!" << endl;
//	if (ispitPRIII.AddObavezu("Pregledati video materijale"))cout << "Obaveza dodana!" << endl;
//	if (ispitPRIII.AddObavezu("Preraditi ispitne zadatke"))cout << "Obaveza dodana!" << endl;
//	if (ispitPRIII.AddObavezu("Samostalno vjezbati"))cout << "Obaveza dodana!" << endl;
//
//	if (ispitBPII.AddObavezu("Preraditi knjigu SQL za 24 h"))cout << "Obaveza dodana!" << endl;
//	if (ispitBPII.AddObavezu("Pregledati video materijale"))cout << "Obaveza dodana!" << endl;
//	if (ispitBPII.AddObavezu("Napraviti bazu za konkretnu aplikaciju"))cout << "Obaveza dodana!" << endl;
//
//	Student jasmin(150051, "Jasmin Azemovic"), adel(160061, "Adel Handzic");
//
//	if (jasmin.AddDogadjaj(ispitPRIII) && jasmin.AddDogadjaj(ispitBPII))
//		cout << "Dogadjaj uspjesno dodan!" << endl;
//
//	if (adel.AddDogadjaj(ispitPRIII) && adel.AddDogadjaj(ispitBPII))
//		cout << "Dogadjaj uspjesno dodan!" << endl;
//	////onemoguciti dupliranje dogadjaja
//	if (!adel.AddDogadjaj(ispitPRIII))
//		cout << "Dogadjaj nije uspjesno dodan!" << endl;
//
//	DLWMSReminder reminder;
//
//	try
//	{
//		reminder.AddStudent(jasmin);
//		reminder.AddStudent(adel);
//		//u slucaju dupliranja studenata funkcija baca izuzetak tipa Izuzetak
//		reminder.AddStudent(jasmin);
//	}
//	catch (exception& err)
//	{
//		Izuzetak iz = dynamic_cast<Izuzetak&>(err); // mozemo izvuci podatke iz exception klase ispisom no treba nam i 
//		                                          //funkcija iz klase izuzetak koja nasljeduje exception tako da je dynamic_cast dobro rjesenje
//		cout << iz << endl;
//		//ispisati sve informacije o nastalom izuzetku
//	}
//
//	////da bi bila oznacena kao zavrsena, obaveza mora postojati i mora biti oznacena kao nezavrsena (false)
//	if (reminder.OznaciObavezuKaoZavrsenu(150051, "Ispit iz PRIII", "Pregledati video materijale"))
//		cout << "Obaveza oznacena kao zavrsena" << endl;
//
//	///*metodi PosaljiNotifikacije se salje trenutni datum na osnovu cega ona pretrazuje sve studente koje treba podsjetiti/notoficirati o dogadjajima koji se priblizavaju.
//	//Koristeci multithread-ing, svim studentima se salju notifikacije sa sljedecim sadrzajem:
//	//-------------------------------------------------------------------------
//	//Postovani Jasmin Azemovic,
//	//Dogadjaj Ispit iz PRIII je zakazan za 3 dana, a do sada ste obavili 56% obaveza vezanih za ovaj dogadjaj. Neispunjene obaveze su:
//	//1.Preraditi ispitne zadatke
//	//2.Samostalno vjezbati
//	//Predlazemo Vam da ispunite i ostale planirane obaveze.
//	//FIT Reminder
//	//-------------------------------------------------------------------------
//	//Dakle, notifikacije ce biti poslane svim studentima koji su dodali dogadjaj za 30.01.2018. godine i oznacili da zele da budu podsjecani ponovo/rekurzivno najmanje 2 dana prije samog dogadjaja (podaci se odnose na konkretan dogadjaj: Ispit iz PRIII)
//	//*/
//	//int poslato = 0;
//	////funkcija vraca broj poslatih podsjetnika/notifikacija
//	//poslato = reminder.PosaljiNotifikacije(danas);
//	//cout << "Za " << danas << " poslato ukupno " << poslato << " podsjetnika!" << endl;
//	//poslato = reminder.PosaljiNotifikacije(sutra);
//	//cout << "Za " << sutra << " poslato ukupno " << poslato << " podsjetnika!" << endl;
//
//#pragma endregion
//
//	system("pause");
//}


///uspjeh

//#include<iostream>
//#include<vector>
//#include<string>
//#include<sstream>
//#include<regex>
//#include<thread>
//#include<mutex>
//using namespace std;
//
//const char* crt = "\n-------------------------------------------\n";
//enum GodinaStudija { PRVA = 1, DRUGA, TRECA };
//mutex m;
//char* Alociraj(const char* sadrzaj) {
//	if (sadrzaj == nullptr)return nullptr;
//	int vel = strlen(sadrzaj) + 1;
//	char* temp = new char[vel];
//	strcpy_s(temp, vel, sadrzaj);
//	return temp;
//}
//
//template<class T1, class T2>
//class Dictionary {
//	T1* _elementi1;
//	T2* _elementi2;
//	int* _trenutno;
//public:
//	Dictionary() {
//		_elementi1 = nullptr;
//		_elementi2 = nullptr;
//		_trenutno = new int(0);
//	}
//
//	Dictionary(const Dictionary& dict) {
//		_trenutno = new int(*dict._trenutno);
//		_elementi1 = new T1[*dict._trenutno];
//		_elementi2 = new T2[*dict._trenutno];
//		for (size_t i = 0; i < *dict._trenutno; i++)
//		{
//			_elementi1[i] = dict._elementi1[i];
//			_elementi2[i] = dict._elementi2[i];
//		}
//		
//	}
//
//	~Dictionary() {
//		delete[]_elementi1; _elementi1 = nullptr;
//		delete[]_elementi2; _elementi2 = nullptr;
//		delete _trenutno; _trenutno = nullptr;
//	}
//	T1& getElement1(int lokacija)const { return _elementi1[lokacija]; }
//	T2& getElement2(int lokacija)const { return _elementi2[lokacija]; }
//	int getTrenutno() { return *_trenutno; }
//	friend ostream& operator<< (ostream& COUT, const Dictionary& obj) {
//		for (size_t i = 0; i < *obj._trenutno; i++)
//			COUT << obj.getElement1(i) << " " << obj.getElement2(i) << endl;
//		return COUT;
//	}
//
//
//	void AddElement(T1 el1, T2 el2) {
//
//		T1* temp1 = new T1[*_trenutno + 1];
//		T2* temp2 = new T2[*_trenutno + 1];
//
//		for (size_t i = 0; i < *_trenutno; i++)
//		{
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//		delete[] _elementi1;delete[] _elementi2;
//
//		temp1[*_trenutno] = el1;
//		temp2[*_trenutno] = el2;
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//		(*_trenutno)++;
//	}
//
//	void operator=(const Dictionary& dict) {
//		if (this != &dict) {
//			delete[]_elementi1;
//			delete[]_elementi2;
//			*_trenutno = *dict._trenutno; // BITNA RAZLIKA DODJELE U ODNOSU NA KONSTRUKTOR KOPIJE, PRIPAZITI!
//			_elementi1 = new T1[*dict._trenutno];
//			_elementi2 = new T2[*dict._trenutno];
//			for (size_t i = 0; i < *dict._trenutno; i++)
//			{
//				_elementi1[i] = dict._elementi1[i];
//				_elementi2[i] = dict._elementi2[i];
//			}
//		}
//	}
//
//	Dictionary getRange(int a, int b) {
//		if (a < b || b < 0) throw exception("Ne postoji lokacija");
//		if(a>*_trenutno || b>*_trenutno)
//			throw exception("Ne postoji lokacija");
//
//		Dictionary<T1, T2> temp;
//		for (size_t i = a; i <=b; i++)
//			temp.AddElement(_elementi1[a], _elementi2[b]);
//		
//		return temp;
//	}
//
//};
//class DatumVrijeme {
//	int* _dan, * _mjesec, * _godina, * _sati, * _minuti;
//public:
//	DatumVrijeme(int dan = 1, int mjesec = 1, int godina = 2000, int sati = 0, int minuti = 0) {
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//		_sati = new int(sati);
//		_minuti = new int(minuti);
//	}
//
//	DatumVrijeme(const DatumVrijeme& dat) {
//		_dan = new int(*dat._dan);
//		_mjesec = new int(*dat._mjesec);
//		_godina = new int(*dat._godina);
//		_sati = new int(*dat._sati);
//		_minuti = new int(*dat._minuti);
//	}
//
//	~DatumVrijeme() {
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//		delete _sati; _sati = nullptr;
//		delete _minuti; _minuti = nullptr;
//	}
//	friend ostream& operator<< (ostream& COUT, const DatumVrijeme& obj) {
//		COUT << *obj._dan << "." << *obj._mjesec << "." << *obj._godina << " " << *obj._sati << ":" << *obj._minuti << endl;
//		return COUT;
//	}
//	//funkcija ToCharArray vraca datum i vrijeme kao char *. konverziju izvrsiti koristeci stringstream objekat.
//	//voditi racuna o tome da se izmedju datuma i vremena nalazi samo jedan razmak, 
//	//te da su vrijednosti dana i mjeseca iskazane kao dvije cifre
//		//treba ispisati: 19/06/2019 10:15
//	char* ToCharArray() {
//		stringstream ss;
//		cout << endl;
//		if (*_dan < 10) ss << "0";
//		ss << *_dan << "/";
//		if (*_mjesec < 10) ss << "0";
//		ss << *_mjesec << "/" << *_godina << " ";
//		ss << *_sati << ":" << *_minuti;
//		return Alociraj(ss.str().c_str());
//	}
//
//	void operator=(const DatumVrijeme& dat) {
//		if (this != &dat) {
//			*_dan = *dat._dan;
//			*_mjesec= *dat._mjesec;
//			*_godina = *dat._godina;
//			*_sati = *dat._sati;
//			*_minuti = *dat._minuti;
//		}
//	}
//	int GetHours() {
//		return *_godina * 8640 + *_mjesec * 720 + *_dan * 24 + *_sati;
//	}
//};
//
//class Predmet {
//	char* _naziv;
//	int _ocjena;
//	string _napomena;
//public:
//	Predmet(const char* naziv = "", int ocjena = 0, string napomena = "") {
//		_naziv = Alociraj(naziv);
//		_ocjena = ocjena;
//		_napomena = napomena;
//	}
//
//	Predmet(const Predmet& predm) {
//		_naziv = Alociraj(predm._naziv);
//		_ocjena = predm._ocjena;
//		_napomena = predm._napomena;
//	}
//
//	~Predmet() {
//		delete[] _naziv; _naziv = nullptr;
//	}
//	friend ostream& operator<< (ostream& COUT, Predmet& obj) {
//		COUT << obj._naziv << " (" << obj._ocjena << ") " << obj._napomena << endl;
//		return COUT;
//	}
//	string GetNapomena() { return _napomena; }
//	char* GetNaziv() { return _naziv; }
//	int GetOcjena() { return _ocjena; }
//
//	void DodajNapomenu(string napomena) {
//		_napomena += " " + napomena;
//	}
//
//	void operator=(const Predmet& predm) {
//		if (this != &predm) {
//			_naziv = Alociraj(predm._naziv);
//			_ocjena = predm._ocjena;
//			_napomena = predm._napomena;
//		}
//	}
//
//	friend bool operator==(const Predmet& predm, const Predmet& predm2) {
//		return strcmp(predm._naziv, predm2._naziv) == 0;
//	}
//};
//class Uspjeh {
//	GodinaStudija* _godina;
//	//datumvrijeme se odnosi na vrijeme evidentiranja polozenog predmeta
//	Dictionary<Predmet, DatumVrijeme> _predmeti;
//public:
//	Uspjeh(GodinaStudija godina) {
//		_godina = new GodinaStudija(godina);
//	}
//	Uspjeh(const Uspjeh& uspj) {
//		_predmeti = uspj._predmeti;
//		_godina = new GodinaStudija(*uspj._godina);
//	}
//
//
//	~Uspjeh() { delete _godina; _godina = nullptr; }
//
//	Dictionary<Predmet, DatumVrijeme>* GetPredmeti() { return &_predmeti; }
//	GodinaStudija* GetGodinaStudija() { return _godina; }
//	friend ostream& operator<< (ostream& COUT, const Uspjeh& obj) {
//		COUT << *obj._godina << " " << obj._predmeti << endl;
//		return COUT;
//	}
//
//	void dodaj(Predmet predm, DatumVrijeme dat) {
//		return _predmeti.AddElement(predm, dat);
//	}
//};
//
//class Student {
//	char* _imePrezime;
//	string _emailAdresa;
//	string _brojTelefona;
//	vector<Uspjeh> _uspjeh;
//	/*
//	email adresa mora biti u formatu: text-text@ nakon cega slijedi neka od sljedecih domena:
//	hotmail.com ili outlook.com ili fit.ba. Pod text se podrazumijeva bilo koje slovo, malo ili veliko.
//	u slucaju da email adresa nije validna, postaviti je na defaultnu: notSet@fit.ba
//	za provjeru koristiti regex
//	*/
//	string validEmail(string rule) {
//		if (regex_match(rule, regex("([a-zA-z]{1,}[-][a-zA-z]{1,})([@])(hotmail.com|outlook.com|fit.ba)"))) return rule;
//		return "notSet@fit.ba";
//	}
//
//public:
//	Student(const char* imePrezime, string emailAdresa, string brojTelefona) {
//		_imePrezime = Alociraj(imePrezime);
//		_emailAdresa = validEmail(emailAdresa);
//		_brojTelefona = brojTelefona;
//	}
//	~Student() {
//		delete[] _imePrezime; _imePrezime = nullptr;
//	}
//	friend ostream& operator<< (ostream& COUT, Student& obj) {
//		COUT << obj._imePrezime << " " << obj._emailAdresa << " " << obj._brojTelefona << endl;
//		return COUT;
//	}
//	vector<Uspjeh>* GetUspjeh() { return &_uspjeh; }
//	string GetEmail() { return _emailAdresa; }
//	string GetBrojTelefona() { return _brojTelefona; }
//	char* GetImePrezime() { return _imePrezime; }
//
//	bool AddPredmet(Predmet predm, GodinaStudija godina, DatumVrijeme dat) {
//		bool sign = false;
//		for (vector<Uspjeh>::iterator i = _uspjeh.begin(); i != _uspjeh.end(); i++)
//		{
//			if (*i->GetGodinaStudija() == godina) {
//				for (size_t j = 0; j < i->GetPredmeti()->getTrenutno(); j++)
//				{
//					if (predm == i->GetPredmeti()->getElement1(j))
//						return false;
//					if (i->GetPredmeti()->getElement2(j).GetHours() >= dat.GetHours())
//						return false;
//				}
//				i->dodaj(predm, dat);
//				sign = true;
//			}
//		}
//		if (!sign) {
//			Uspjeh usp(godina);
//			usp.dodaj(predm, dat);
//			_uspjeh.push_back(usp);
//		}
//		thread t1([&]() {
//			m.lock();
//			cout << "FROM:info@fit.ba" << endl << "TO : emailStudenta" << endl << "Postovani ime i prezime, evidentirali ste uspjeh za " << godina << " godinu studija." << endl << "Pozdrav." << endl << "FIT Team." << endl;
//			m.unlock();
//			});
//
//		thread t2([&]() {
//			float prosjek = 0;
//			for (vector<Uspjeh>::iterator i = this->GetUspjeh()->begin(); i != this->GetUspjeh()->end(); i++)
//			{
//				if (*i->GetGodinaStudija() == godina) {
//					for (size_t j = 0; j < i->GetPredmeti()->getTrenutno(); j++)
//					{
//						prosjek += i->GetPredmeti()->getElement1(j).GetOcjena();
//					}
//					prosjek /= i->GetPredmeti()->getTrenutno();
//				}
//			}
//			if (prosjek > 8) {
//				cout << "Saljem sms " << endl << " Svaka cast za uspjeh " << prosjek << " ostvaren u " << godina << " godini studija" << endl;
//			}
//		});
//
//		t1.join();
//		t2.join();
//		return true;
//	}
//
//	vector<Predmet> operator()(DatumVrijeme* OD, DatumVrijeme* DO) {
//		vector<Predmet> p;
//		for (size_t i = 0; i < _uspjeh.size(); i++)
//		{
//			for (size_t j = 0; j < _uspjeh[i].GetPredmeti()->getTrenutno(); j++)
//			{
//				if (_uspjeh[i].GetPredmeti()->getElement2(j).GetHours() >= OD->GetHours() && DO->GetHours() >= _uspjeh[i].GetPredmeti()->getElement2(j).GetHours()) {
//					p.push_back(_uspjeh[i].GetPredmeti()->getElement1(j));
//				}
//			}
//		}
//		return p;
//	}
//
//	Uspjeh* operator[](string gs) {
//		for (size_t i = 0; i < _uspjeh.size(); i++)
//		{
//			if (gs == "PRVA" && *_uspjeh[i].GetGodinaStudija() == PRVA) return &_uspjeh[i];
//			if (gs == "DRUGA" && *_uspjeh[i].GetGodinaStudija() == DRUGA) return &_uspjeh[i];
//			if (gs == "TRECA" && *_uspjeh[i].GetGodinaStudija() == TRECA) return &_uspjeh[i];
//		}
//		return nullptr;
//	}
//	int BrojPonavljanjaRijeci(string substr) {
//		int brojPonavljanja = 0;
//		for (size_t i = 0; i < _uspjeh.size(); i++)
//		{
//			for (size_t j = 0; j < _uspjeh[i].GetPredmeti()->getTrenutno(); j++)
//			{
//				regex r("(\\b" + substr + "\\b|\\B" + substr + "\\B)");
//				string napomena = _uspjeh[i].GetPredmeti()->getElement1(j).GetNapomena();
//				auto start = sregex_iterator(napomena.begin(), napomena.end(), r);
//				auto end = sregex_iterator();
//				brojPonavljanja += distance(start, end);
//			}
//		}
//		return brojPonavljanja;
//	}
//	
//};
//
//void main() {
//	/****************************************************************************
//	1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR ĆE BITI OZNACENO KAO "RE"
//	3. SPAŠAVAJTE PROJEKAT KAKO BI SE SPRIJEČILO GUBLJENJE URAĐENOG ZADATKA
//	4. PROGRAMSKI CODE SE TAKOĐER NALAZI U FAJLU CODE.TXT
//	5. NAZIVI FUNKCIJA, TE BROJ I TIP PARAMETARA MORAJU BITI IDENTIČNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U, OSIM U SLUČAJU DA POSTOJI ADEKVATAN RAZLOG ZA NJIHOVU MODIFIKACIJU. OSTALE, POMOĆNE FUNKCIJE MOŽETE IMENOVATI I DODAVATI PO ŽELJI.
//	6. IZUZETAK BACITE U FUNKCIJAMA U KOJIMA JE TO NAZNAČENO.
//	****************************************************************************/
//	cout << "NA KRAJU ISPITA, RAD PREDAJTE U ODGOVARAJUCI FOLDER NA FTP SERVERU (INTEGRALNI)!" << endl;
//	DatumVrijeme temp,
//		datum19062019_1015(19, 6, 2019, 10, 15),
//		datum20062019_1115(20, 6, 2019, 11, 15),
//		datum30062019_1215(30, 6, 2019, 12, 15),
//		datum05072019_1231(5, 7, 2019, 12, 31);
//	//funkcija ToCharArray vraca datum i vrijeme kao char *. konverziju izvrsiti koristeci stringstream objekat.
//	//voditi racuna o tome da se izmedju datuma i vremena nalazi samo jedan razmak, 
//	//te da su vrijednosti dana i mjeseca iskazane kao dvije cifre
//	cout << datum19062019_1015.ToCharArray() << endl;//treba ispisati: 19/06/2019 10:15
//	temp = datum05072019_1231;
//	cout << temp.ToCharArray() << endl;//treba ispisati: 05/07/2019 12:31
//
//	const int DictionaryTestSize = 9;
//	Dictionary<int, int> Dictionary1;
//	for (size_t i = 0; i < DictionaryTestSize; i++)
//		Dictionary1.AddElement(i + 1, i * i);
//
//	try {
//	//	//vraca elemente kolekcije koji se nalaze na lokacijama definisanim vrijednostima parametara (npr. 2 - 7). 
//	//	//funkcija baca izuzetak u slucaju da se zahtijeva lokacija koja ne postoji ili je vrijednost posljednje lokacije manja od pocetne
//		Dictionary<int, int> opseg = Dictionary1.getRange(2, 7);
//		cout << opseg << endl;
//		Dictionary1.getRange(7, 11);
//	}
//	catch (exception& err) {
//		cout << err.what() << endl;
//	}
//	cout << Dictionary1 << endl;
//
//	Dictionary<int, int> Dictionary2 = Dictionary1;
//	cout << Dictionary2 << crt;
//
//	Dictionary<int, int> Dictionary3;
//	Dictionary3 = Dictionary1;
//	cout << Dictionary3 << crt;
//
//	//napomena se moze dodati i prilikom kreiranja objekta
//	Predmet MAT("Matematika", 7, "Ucesce na takmicenju"),
//		UIT("Uvod u informacijske tehnologije", 9),
//		RM("Racunarske mreze", 8),
//		EN("Engleski jezik", 6);
//	UIT.DodajNapomenu("Pohvala za ostvareni uspjeh");
//	cout << MAT << endl;
//
//	/*
//	email adresa mora biti u formatu: text-text@ nakon cega slijedi neka od sljedecih domena: 
//	hotmail.com ili outlook.com ili fit.ba. Pod text se podrazumijeva bilo koje slovo, malo ili veliko.
//	u slucaju da email adresa nije validna, postaviti je na defaultnu: notSet@fit.ba
//	za provjeru koristiti regex
//	*/
//	Student jasmin("Jasmin Azemovic", "jasmin.azemovic@hotmail.com", "033 281 172");
//	Student adel("Adel Handzic", "adel.handzic@fit.ba", "033 281 170");
//	Student emailNotValid("Ime Prezime", "korisnik@lazna.ba", "033 281 170");
//
//
//	///*
//	//uspjeh se dodaje za svaki predmet na nivou godine studija.
//	//tom prilikom onemoguciti:
//	//- dodavanje istoimenih predmeta na nivou jedne godine,
//	//- dodavanje vise predmeta u kratkom vremenskom periodu (na nivou jedne godine, razmak izmedju dodavanja pojedinih predmeta mora biti najmanje 1 sat).
//	//godine (predmeti ili uspjeh) ne moraju biti dodavani sortiranim redoslijedom (npr. prvo se moze dodati uspjeh za drugu godinu, pa onda za prvu godinu i sl.).
//	//Funkcija vraca true ili false u zavisnosti od (ne)uspjesnost izvrsenja
//	//*/
//	if (jasmin.AddPredmet(UIT, DRUGA, datum20062019_1115))
//		cout << "Predmet uspjesno dodan!" << crt;
//	if (jasmin.AddPredmet(RM, DRUGA, datum30062019_1215))
//		cout << "Predmet uspjesno dodan!" << crt;
//	if (jasmin.AddPredmet(EN, PRVA, datum19062019_1015))
//		cout << "Predmet uspjesno dodan!" << crt;
//	if (jasmin.AddPredmet(MAT, PRVA, datum20062019_1115))
//		cout << "Predmet uspjesno dodan!" << crt;
//	//ne treba dodati MAT jer je vec dodana u prvoj godini
//	if (jasmin.AddPredmet(MAT, PRVA, datum05072019_1231))
//		cout << "Predmet uspjesno dodan!" << crt;
//	//ne treba dodati UIT jer nije prosao 1 sat od dodavanja posljednjeg predmeta
//	if (jasmin.AddPredmet(UIT, PRVA, datum20062019_1115))
//		cout << "Predmet uspjesno dodan!" << crt;
//	///*nakon evidentiranja uspjeha na bilo kojem predmetu tj. prilikom uspjesno izvrsene funkcije AddPredmet, Studentu se salje email sa sadrzajem:
//	//FROM:info@fit.ba
//	//TO: emailStudenta
//	//Postovani ime i prezime, evidentirali ste uspjeh za X godinu studija.
//	//Pozdrav.
//	//FIT Team.
//	//ukoliko je, nakon dodavanja predmeta, prosjek na nivou te godine veci od 8.0 Studentu se, pored email-a, salje i SMS sa sadrzajem: "Svaka cast za uspjeh X.X ostvaren u X godini studija".
//	//slanje poruka i emailova implemenitrati koristeci zasebne thread-ove.
//	//*/
//	cout << "USPJEH ISPISATI KORISTEĆI OSTREAM_ITERATOR" << endl;
//	cout << jasmin << endl;
//	////vraca broj ponavljanja odredjene rijeci u napomenama, koristiti sregex_iterator
//	cout << "Rijec takmicenje se pojavljuje " << jasmin.BrojPonavljanjaRijeci("takmicenju") << " puta." << endl;
//
//	////vraca niz predmeta koji su evidentiranih u periodu izmedju vrijednosti proslijedjenih parametara
//	vector<Predmet> jasminUspjeh = jasmin(new DatumVrijeme(18, 06, 2019, 10, 15), new DatumVrijeme(21, 06, 2019, 10, 10));
//	for (Predmet u : jasminUspjeh)
//		cout << u << endl;
//
//	Uspjeh* uspjeh_I_godina = jasmin["PRVA"];//vraca uspjeh Studenta ostvaren u prvoj godini studija
//	if (uspjeh_I_godina != nullptr)
//		cout << *uspjeh_I_godina << endl;
//
//	cin.get();
//	system("pause>0");
//}





//zavrsniRad

//#include<iostream>
//#include<vector>
//#include<string>
//#include<regex>
//#include<thread>
//#include<mutex>
//using namespace std;
//
//const char* nedozvoljena_operacija = "Nedozvoljena operacija";
//const char* not_set = "NOT_SET";
//const int min_polgavlja = 3;
//const int min_karaktera_po_poglavlju = 30;
//
//char* AlocirajNizKaraktera(const char* sadrzaj) {
//	if (sadrzaj == nullptr)
//		return nullptr;
//	int vel = strlen(sadrzaj) + 1;
//	char* temp = new char[vel];
//	strcpy_s(temp, vel, sadrzaj);
//	return temp;
//}
//
//template<class T1, class T2>
//class Kolekcija {
//	T1* _elementi1;
//	T2* _elementi2;
//	int _trenutno;
//public:
//	Kolekcija() :_trenutno(0), _elementi1(nullptr), _elementi2(nullptr) { }
//
//	void AddElement(const T1& elem1, const T2& elem2) {
//
//		for (int i = 0; i < _trenutno; i++)
//			if (_elementi1[i] == elem1 || _elementi2[i] == elem2)
//				throw exception(nedozvoljena_operacija);
//
//		T1* temp1 = new T1[_trenutno + 1];
//		T2* temp2 = new T2[_trenutno + 1];
//		for (int i = 0; i < _trenutno; i++) {
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//		delete[] _elementi1; _elementi1 = nullptr;
//		delete[] _elementi2; _elementi2 = nullptr;
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//
//		_elementi1[_trenutno] = elem1;
//		_elementi2[_trenutno++] = elem2;
//
//	}
//
//	T1* getElementi1Pok() { return _elementi1; }
//	T2* getElementi2Pok() { return _elementi2; }
//	T1& getElement1(int lokacija) { return _elementi1[lokacija]; }
//	T2& getElement2(int lokacija) { return _elementi2[lokacija]; }
//	int getTrenutno() { return _trenutno; }
//
//	friend ostream& operator<<(ostream& COUT, Kolekcija<T1, T2>& obj) {
//		for (size_t i = 0; i < obj._trenutno; i++)
//			COUT << obj.getElement1(i) << " " << obj.getElement2(i) << endl;
//		return COUT;
//	}
//};
//class Poglavlje {
//	char* _naslov;
//	char* _sadrzaj;
//	bool _prihvaceno;
//	int _ocjena;//da bi se poglavlje smatralo prihvacenim ocjena mora biti u opsegu od 6 - 10
//public:
//	Poglavlje(const char* naslov = nullptr, const char* sadrzaj = nullptr)
//		:_ocjena(0), _prihvaceno(false) {
//		_naslov = AlocirajNizKaraktera(naslov);
//		_sadrzaj = AlocirajNizKaraktera(sadrzaj);
//	}
//
//	Poglavlje(const Poglavlje& pogl) {
//		_naslov = AlocirajNizKaraktera(pogl._naslov);
//		_sadrzaj = AlocirajNizKaraktera(pogl._sadrzaj);
//		OcijeniPoglavlje(pogl._ocjena);
//	}
//
//	Poglavlje() {
//		delete[] _naslov; _naslov = nullptr;
//		delete[] _sadrzaj; _sadrzaj = nullptr;
//	}
//	friend ostream& operator<<(ostream& COUT, Poglavlje& obj) {
//		if (obj._naslov == nullptr || obj._sadrzaj == nullptr)
//			return COUT;
//		COUT << endl << obj._naslov << endl << obj._sadrzaj << endl;
//		if (obj._prihvaceno)
//			COUT << "Ocjena: " << obj._ocjena << endl;;
//		return COUT;
//	}
//	char* GetNaslov() { return _naslov; }
//	char* GetSadrzaj() { return _sadrzaj; }
//	bool GetPrihvaceno() { return _prihvaceno; }
//	int GetOcjena() { return _ocjena; }
//
//	void OcijeniPoglavlje(int ocjena) {
//		_ocjena = ocjena;
//		if (_ocjena > 5 && ocjena <= 10)
//			_prihvaceno = true;
//	}
//
//	void SetSadrzaj(string sadrzaj) {
//		char* temp = AlocirajNizKaraktera((sadrzaj+string(_sadrzaj)).c_str());
//		delete[]_sadrzaj;
//		_sadrzaj = temp;
//	}
//
//	void operator=(const Poglavlje& pogl) {
//		if (this != &pogl) {
//			delete[]_naslov;
//			delete[]_sadrzaj;
//			_naslov = AlocirajNizKaraktera(pogl._naslov);
//			_sadrzaj = AlocirajNizKaraktera(pogl._sadrzaj);
//			OcijeniPoglavlje(pogl._ocjena);
//		}
//	}
//};
//
//class ZavrsniRad {
//	char* _tema;
//	vector<Poglavlje> _poglavljaRada;
//	string _datumOdbrane;
//	float _konacnaOcjena; //prosjek ocjena svih poglavlja u zavrsnom radu koja se izracunava u momentu zakazivanja odbrane
//public:
//	ZavrsniRad(const char* nazivTeme = nullptr) : _konacnaOcjena(0), _datumOdbrane(not_set) {
//		_tema = AlocirajNizKaraktera(nazivTeme);
//	}
//
//	ZavrsniRad(const ZavrsniRad& org) : _poglavljaRada(org._poglavljaRada), _konacnaOcjena(org._konacnaOcjena), _datumOdbrane(org._datumOdbrane) {
//		_tema = AlocirajNizKaraktera(org._tema);
//	}
//
//	~ZavrsniRad() {
//		delete[] _tema; _tema = nullptr;
//	}
//	char* GetNazivTeme()const { return _tema; }
//	vector<Poglavlje>& GetPoglavlja() { return _poglavljaRada; };
//	string GetDatumOdbrane()const { return _datumOdbrane; }
//	float GetOcjena() { return _konacnaOcjena; }
//	friend ostream& operator<<(ostream& COUT, ZavrsniRad& obj) {
//		COUT << "Tema rada: " << obj._tema << endl;
//		COUT << "Sadrzaj: " << endl;
//		for (size_t i = 0; i < obj._poglavljaRada.size(); i++)
//			COUT << obj._poglavljaRada[i] << endl;
//		COUT << "Datum odbrane rada: " << obj._datumOdbrane << endl << " Ocjena: " << obj._konacnaOcjena << endl;
//		return COUT;
//	}
//
//	void DodajPoglavlje(string naslov, string sadrzaj) {
//		for (vector<Poglavlje>::iterator i = _poglavljaRada.begin(); i != _poglavljaRada.end(); i++)
//		{
//			if (i->GetNaslov() == naslov) {
//				i->SetSadrzaj(sadrzaj);
//				return;
//			}
//		}
//		_poglavljaRada.push_back(Poglavlje(naslov.c_str(), sadrzaj.c_str()));
//	}
//
//	void OcijeniPoglavlje(string naslov, int ocjena) {
//		for (vector<Poglavlje>::iterator i = _poglavljaRada.begin(); i != _poglavljaRada.end(); i++)
//		{
//			if (i->GetNaslov() == naslov)
//				i->OcijeniPoglavlje(ocjena);
//			
//		}
//	}
//
//	void operator=(const ZavrsniRad& zr) {
//		if (this != &zr) {
//			delete[]_tema;
//			_tema = AlocirajNizKaraktera(zr._tema);
//			_poglavljaRada = zr._poglavljaRada;
//			_datumOdbrane = zr._datumOdbrane;
//			_konacnaOcjena = zr._konacnaOcjena;
//		}
//	}
//
//	bool operator==(const ZavrsniRad& zr) {
//		return strcmp(_tema, zr._tema) == 0;
//	}
//
//	void SetKonacnaOcjena(float ocjena) {
//		_konacnaOcjena = ocjena;
//	}
//	
//	void SetDatumOdbrane(string datum) {
//		_datumOdbrane = datum;
//	}
//
//	int GetKonacna() { return _konacnaOcjena; }
//};
//
//class Osoba {
//protected:
//	string _imePrezime;
//public:
//	Osoba(string imePrezime) : _imePrezime(imePrezime) {}
//	string GetImePrezime() { return _imePrezime; }
//	virtual void Info() = 0;
//
//	friend ostream& operator<<(ostream& cout, const Osoba& os) {
//		cout << "Ime i prezime: " << os._imePrezime << endl;
//		return cout;
//	}
//};
//
//mutex m;
//class Nastavnik:public Osoba {
//	//Parametar string predstavlja broj indeksa studenta koji prijavljuje zavrsni rad kod odredjenog nastavnika
//	Kolekcija<string, ZavrsniRad> _teme;
//public:
//	Kolekcija<string, ZavrsniRad>& GetTeme() { return _teme; };
//	Nastavnik(string imePrezime):Osoba(imePrezime){}
//
//
//	bool DodajZavrsniRad(string indeks, ZavrsniRad &zr) {
//		try
//		{
//			_teme.AddElement(indeks, zr);
//			return true;
//		}
//		catch (const std::exception& e)
//		{
//			return false;
//		}
//	}
//
//	ZavrsniRad* ZakaziOdbranuRada(string brojIndeksa, string datumOdbrane) {
//		for (size_t i = 0; i < _teme.getTrenutno(); i++)
//		{
//				float konacna = 0;
//			if (brojIndeksa == _teme.getElement1(i)) {
//				if (_teme.getElement2(i).GetPoglavlja().size() < min_polgavlja)
//					return nullptr;
//				for (vector<Poglavlje>::iterator j = _teme.getElement2(i).GetPoglavlja().begin(); j!= _teme.getElement2(i).GetPoglavlja().end(); j++)
//				{
//					if (strlen(j->GetSadrzaj()) < min_karaktera_po_poglavlju || !j->GetPrihvaceno())
//						return nullptr;
//					konacna += j->GetOcjena();
//				}
//				konacna /= _teme.getElement2(i).GetPoglavlja().size();
//				_teme.getElement2(i).SetDatumOdbrane(datumOdbrane);
//				_teme.getElement2(i).SetKonacnaOcjena(konacna);
//				return &_teme.getElement2(i);
//			}
//		}
//
//		return nullptr;
//	}
//
//	friend ostream& operator<<(ostream& cout, Nastavnik& nast) {
//		cout << dynamic_cast<Osoba&>(nast) << endl;
//		cout << "Tema: " << nast._teme << endl;
//		return cout;
//	}
//
//	void Info() {
//		cout << *this << endl;
//	}
//
//};
//
//
//string PosaljiPozivZaDodjeluNagrada(Nastavnik** nastavnici, int brojac, float ocjena) {
//	string poruka = not_set;
//	Nastavnik* n = nullptr;
//	float najmprosjek = INT_MAX;
//	
//	for (size_t i = 0; i < brojac; i++)
//	{
//		float prosjek = 0;
//		int ctr = 0;
//		for (size_t j = 0; j < nastavnici[i]->GetTeme().getTrenutno(); j++)
//		{
//			if (nastavnici[i]->GetTeme().getElement2(j).GetOcjena() > 5) {
//				prosjek += nastavnici[i]->GetTeme().getElement2(j).GetOcjena();
//				ctr++;
//			}
//		}
//		if (ctr != 0) {
//			prosjek /= ctr;
//			if (prosjek < najmprosjek) {
//				najmprosjek = prosjek;
//				n = nastavnici[i];
//			}
//		}
//	}
//
//	if (n != nullptr) {
//		for (size_t i = 0; i < n->GetTeme().getTrenutno(); i++)
//		{
//			if (n->GetTeme().getElement2(i).GetKonacna() >= ocjena) {
//				string temp="Postovani"+n->GetTeme().getElement1(i)+", uzimajuci u obzir cinjenicu da ste kod mentora"+
//					n->GetImePrezime()+" uspjesno odbranili rad sa ocjenom "+to_string(n->GetTeme().getElement2(i).GetKonacna())+
//					" cast nam je pozvati vas na dodjelu nagrada za najbolje studente koja ce se odrzatu u na FIT - u 20.09.2018.godine.";
//				poruka += temp;
//				thread t([temp](string email) {
//					m.lock();
//					cout << "Saljem mail -> " << email << endl;
//					cout << temp << endl;
//					m.unlock();
//					}, n->GetTeme().getElement1(i) + "@edu.fit.ba");
//				t.join();
//			}
//
//		}
//	}
//		return poruka;
//}
//
//
//int main() {
//	const int max = 4;
//	Nastavnik* nastavnici[max];
//
//	nastavnici[0] = new Nastavnik("Denis Music");
//	nastavnici[1] = new Nastavnik("Zanin Vejzovic");
//	nastavnici[2] = new Nastavnik("Jasmin Azemovic");
//	nastavnici[3] = new Nastavnik("Emina Junuz");
//
//
//	ZavrsniRad multimedijalni("Multimedijalni informacijski sistem za visoko - obrazovnu ustanovu");
//	ZavrsniRad podrsa_operaterima("Sistem za podršku rada kablovskog operatera");
//	ZavrsniRad analiza_sigurnosti("Prakticna analiza sigurnosti bežičnih računarskih mreža");
//	ZavrsniRad kriptografija("Primjena teorije informacija u procesu generisanja kriptografskih ključeva");
//
//
//	/*u zavrsni rad dodaje novo poglavlje i njegov sadrzaj. 
//	ukoliko poglavlje vec postoji u zavrsnom radu, funkcija 
//	tom poglavlju treba dodati novi sadrzaj i pri tome zadrzi postojeci 
//	(izmedju postojeceg i novog sadrzaja se dodaje prazan prostor). 
//	u slucaju da poglavlje ne postoji, ono se dodaje zajedno sa sadrzaje*/
//	//nazivPoglavlja, sadrzajPoglavlja
//	multimedijalni.DodajPoglavlje("Uvod", "U ovom poglavlju ce biti rijeci");
//	multimedijalni.DodajPoglavlje("Uvod", "o multimedijalnim sistemima koji se danas koriste");
//	multimedijalni.DodajPoglavlje("Uvod", "u savremenom poslovanju");
//	multimedijalni.DodajPoglavlje("Vrste multimedijalnih sistema", "Danas se moze govoriti o nekoliko vrsta multimedijalnih sistema, a neke od najznacajnijih su ...");
//	multimedijalni.DodajPoglavlje("Teorija multimedije", "Sadrzaj koji bi trebao stajati na pocetku treceg poglavlja zavrsnog rada o multimediji studenta IB130011");
//
//	//nazivPoglavlja, ocjena
//multimedijalni.OcijeniPoglavlje("Uvod", 8);
//multimedijalni.OcijeniPoglavlje("Teorija multimedije", 6);
//multimedijalni.OcijeniPoglavlje("Vrste multimedijalnih sistema", 9);
//
//
//	/*funkcija DodajZavrsniRad ima zadatak da odredjenom nastavniku dodijeli mentorstvo na zavrsnom radu. 
//zavrsni rad se dodaje studentu sa brojem indeksa proslijedjenim kao prvi parametar.
//	sprijeciti dodavanje zavrsnih radova sa istom temom*/
//	//brojIndeksa, zavrsniRad
//	if (nastavnici[0]->DodajZavrsniRad("IB130011", multimedijalni))
//		cout << "Zavrsni rad uspjesno dodat!" << endl;
//	if (nastavnici[0]->DodajZavrsniRad("IB120051", podrsa_operaterima))
//		cout << "Zavrsni rad uspjesno dodat!" << endl;
//	if (!nastavnici[0]->DodajZavrsniRad("IB120056", podrsa_operaterima))//dupliranje rada
//		cout << "Zavrsni rad nije dodat!" << endl;
//	if (!nastavnici[0]->DodajZavrsniRad("IB120051", kriptografija)) //studentu vec dodijeljen rad
//		cout << "Zavrsni rad nije dodat!" << endl;
//	if (nastavnici[1]->DodajZavrsniRad("IB140102", analiza_sigurnosti))
//		cout << "Zavrsni rad uspjesno dodat!" << endl;
//	if (nastavnici[2]->DodajZavrsniRad("IB140002", kriptografija))
//		cout << "Zavrsni rad uspjesno dodat!" << endl;
//
//	/*funkcija ZakaziOdbranuRada ima zadatak da studentu sa proslijedjenim brojem indeksa zakaze 
//	odbranu zavrsnog rada sto podrazumijeva definisanje
//	datuma odbrane. odbrana rada se moze zakazati samo studentu koji je rad prethodno prijavio.
//	Za zakazivanje odbrane rada moraju biti zadovoljeni sljedeci uslovi:
//				   1. zavrsni rad mora imati broj poglavlja veci od minimalnog
//				   2. svako poglavlje mora imati broj karaktera veci od minimalnog
//				   3. svako poglavlje mora biti prihvaceno/odobreno
//	ukoliko su zadovoljeni prethodni kriteriji, izracunava se konacna ocjena rada (prosjek ocjena svih poglavlja), postavlja datum odbrane rada i vraca pokazivac na rad kome je zakazan odbrana.
//	u slucaju da student sa primljenim brojem indeksa nije prijavio zavrsni rad ili neki od postavljenih kriterija nije zadovoljen, funkcija vraca nullptr.
//*/
//
////brojIndeksa, datumOdbrane
//	ZavrsniRad* zr1 = nastavnici[0]->ZakaziOdbranuRada("IB130011", "25.09.2018");
//	if (zr1 != nullptr)
//		cout << *zr1 << endl;
//
//	zr1 = nastavnici[0]->ZakaziOdbranuRada("IB130111", "25.09.2018");//student sa brojem indeksa IB130111 jos uvijek nije prijavio rad
//	if (zr1 != nullptr)
//		cout << *zr1 << endl;
//
//	//ispisuje sve podatke o nastavniku i njegovim mentorstvima
//	cout << *nastavnici[0] << endl;
//
//	/*Funkcija PronadjiNajStudenta ima zadatak da svim studentima koji su uspjesno okoncali svoj zavrsni rad kod nastavnika/mentora sa najnizom prosjecnom ocjenom
//	i tom prilikom ostvarili ocjenu vecu od proslijedjene, u zasebnom thread.u, posalje email poruku (mail adresa: brojIndeksa@edu.fit.ba) sa sadrzajem, "Postovani {brojIndeksa}, uzimajuci u obzir cinjenicu da ste kod mentora {imePrezimeMentora} uspjesno odbranili rad sa ocjenom {ocjena} cast nam je pozvati vas na dodjelu nagrada za najbolje studente koja ce se odrzatu u na FIT-u 20.09.2018. godine."
//	da su svoj zavrsni rad uspjesno odbranili sa vecom ili manjom ocjenom od prosjecne.
//	funkcija treba da vrati sadrzaj svih poslatih email poruka, a ukoliko niti jedan od nastavnika ne posjeduje evidentirano mentorstvo na zavrsnom radu, funkcija vraca not_set*/
//	cout << "Studenti za dodjelu nagrada: " << PosaljiPozivZaDodjeluNagrada(nastavnici, max, 9.5) << endl;
//
//	/*
//	Koristeci postojeci programski code, demonstrirati i ukratko opisati polimorfizam.
//	*/
//
//	for (int i = 0; i < max; i++)
//	{
//		delete nastavnici[i];
//		nastavnici[i] = nullptr;
//	}
//	system("pause>0");
//	return 0;
//}

// printer

//#include <iostream>
//#include<vector>
//#include<string>
//#include<algorithm>
//#include<regex>
//using namespace std;
//
//const char* crt = "\n---------------------------------------\n";
//
//class DatumVrijeme
//{
//	int* _dan, * _mjesec, * _godina, * _sati, * _minuti;
//public:
//	DatumVrijeme(int dan = 1, int mjesec = 1, int godina = 2000, int sati = 0, int minuti = 0)
//	{
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//		_sati = new int(sati);
//		_minuti = new int(minuti);
//	}
//	DatumVrijeme(const DatumVrijeme& dat) {
//		_dan = new int(*dat._dan);
//		_mjesec= new int(*dat._mjesec);
//		_godina = new int(*dat._godina);
//		_sati = new int(*dat._sati);
//		_minuti = new int(*dat._minuti);
//	}
//
//	~DatumVrijeme()
//	{
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//		delete _sati; _sati = nullptr;
//		delete _minuti; _minuti = nullptr;
//	}
//	friend ostream& operator<< (ostream& COUT, DatumVrijeme& obj)
//	{
//		COUT << *obj._dan << "." << *obj._mjesec << "." << *obj._godina << " " << *obj._sati << ":" << *obj._minuti;
//		return COUT;
//	}
//
//	void operator=(const DatumVrijeme& dat) {
//		if (this != &dat) {
//			*_dan = *dat._dan;
//			*_mjesec= *dat._mjesec;
//			*_godina = *dat._godina;
//			*_sati = *dat._sati;
//			*_minuti= *dat._minuti;
//		}
//	}
//
//	bool operator == (const DatumVrijeme& d) {
//		return *_dan == *d._dan && *_mjesec == *d._mjesec && *_godina == *d._godina && *_sati == *d._sati;
//	}
//};
//
//template<class T1, class T2 = int>
//class FITKolekcija
//{
//	T1* _elementi1;
//	T2* _elementi2;
//	int _trenutno;
//public:
//	FITKolekcija()
//	{
//		_elementi1 = nullptr;
//		_elementi2 = nullptr;
//		_trenutno = 0;
//	}
//	FITKolekcija(const FITKolekcija &f){
//		_trenutno = f._trenutno;
//		_elementi1 = new T1[f._trenutno];
//		_elementi2 = new T2[f._trenutno];
//		for (size_t i = 0; i < f._trenutno; i++)
//		{
//			_elementi1[i] = f._elementi1[i];
//			_elementi2[i] = f._elementi2[i];
//		}
//	}
//	~FITKolekcija()
//	{
//		delete[] _elementi1; _elementi1 = nullptr;
//		delete[] _elementi2; _elementi2 = nullptr;
//	}
//	T1* GetT1()const { return _elementi1; }
//	T2* GetT2() const{ return _elementi2; }
//	int GetTrenutno()const { return _trenutno; }
//
//	friend ostream& operator<< (ostream& COUT, FITKolekcija& obj)
//	{
//		for (size_t i = 0; i < obj._trenutno; i++)
//			COUT << obj._elementi1[i] << " " << obj._elementi2[i] << endl;
//		return COUT;
//	}
//
//	void Dodaj(T1 el1, T2 el2) {
//
//		T1* temp1 = new T1[_trenutno + 1];
//		T2* temp2 = new T2[_trenutno + 1];
//		for (size_t i = 0; i < _trenutno; i++)
//		{
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//		delete[]_elementi1; delete[]_elementi2;
//		temp1[_trenutno] = el1;
//		temp2[_trenutno] = el2;
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//		_trenutno++;
//	}
//
//	void Sortiraj() { // samo elemente tipa t1 treba sortirat
//
//		bool sort = true;
//		while (sort)
//		{
//			sort = false;
//			for (size_t i = 0; i < _trenutno-1; i++)
//			{
//				if (_elementi1[i] > _elementi1[i + 1]) {
//					T1 temp1 = _elementi1[i];
//					T2 temp2 = _elementi2[i];
//					_elementi1[i] = _elementi1[i + 1];
//					_elementi2[i] = _elementi2[i + 1];
//					_elementi1[i + 1] = temp1;
//					_elementi2[i + 1] = temp2;
//					sort = true;
//				}
//			}
//		}
//	}
//
//	bool DodajNaLokaciju(T1 el1, T2 el2, int index) {
//		if (index<0 || index>=_trenutno)
//			return false;
//
//		Dodaj(el1, el2);
//		swap(_elementi1[_trenutno - 1], _elementi1[index]);
//		swap(_elementi2[_trenutno - 1], _elementi2[index]);
//	}
//
//	FITKolekcija<T1,T2>* GetJedinstveni() {
//
//		FITKolekcija<T1, T2>* el = new FITKolekcija<T1, T2>;
//		bool dodaj = false;
//		for (size_t i = 0; i < _trenutno; i++)
//		{
//			dodaj = false;
//			for (size_t j = 0; j < el->GetTrenutno(); j++)
//				if (el->GetT1()[j] == _elementi1[i] && el->GetT2()[j] == _elementi2[i])
//					dodaj = true;
//			
//			if (!dodaj) // AKO SE NISU DODALI U TRUE KAO ONI KOJI SE PONAVLJAJU DODAJ IH U NOVU LISTU!
//				el->Dodaj(_elementi1[i], _elementi2[i]);
//		}
//		return el;
//	}
//
//	void operator=(const FITKolekcija& kol) {
//		if (this != &kol) {
//			delete[]_elementi1;
//			delete[]_elementi2;
//			_trenutno = kol._trenutno;
//			_elementi1 = new T1[kol._trenutno];
//			_elementi2 = new T2[kol._trenutno];
//			for (size_t i = 0; i < kol._trenutno; i++)
//			{
//				_elementi1[i] = kol._elementi1[i];
//				_elementi2[i] = kol._elementi2[i];
//			}
//		}
//	}
//};
//
//enum vrstaDokumenta { PDF, DOC, TXT, HTML };
//
//class Dokument
//{
//	vrstaDokumenta _vrsta;
//	string _naziv;
//	string _sadrzaj;
//	int _brojStranica;
//public:
//	Dokument() { _brojStranica = 0; _naziv = "NOT_SET"; _sadrzaj = "NOT_SET"; }
//
//	Dokument(vrstaDokumenta vrsta, string naziv)
//	{
//		_naziv = naziv; _vrsta = vrsta; _brojStranica = 0;
//		_sadrzaj = "";
//	}
//	string GetNaziv() { return _naziv; };
//	string GetSadrzaj() { return _sadrzaj; };
//	vrstaDokumenta GetVrsta() { return _vrsta; };
//	void UvecajBrojStranica() { _brojStranica++; }
//	int GetBrojStranica() { return _brojStranica; }
//	friend ostream& operator<<(ostream& COUT, Dokument& obj)
//	{
//		COUT << obj._naziv << "." << obj._vrsta << " (" << obj._brojStranica << ")\n" << obj._sadrzaj << endl;
//		return COUT;
//	}
//
//	void DodajSadrzaj(string sadrzaj) {
//		_sadrzaj += sadrzaj;
//		_brojStranica = _sadrzaj.length() / 30;
//	}
//
//
//};
//
//class Uredjaj
//{
//protected:
//	char* _proizvodjac;
//	char* _model;
//public:
//	Uredjaj(const char* proizvodjac, const char* model)
//	{
//		int vel = strlen(proizvodjac) + 1;
//		_proizvodjac = new char[vel];
//		strcpy_s(_proizvodjac, vel, proizvodjac);
//		vel = strlen(model) + 1;
//		_model = new char[vel];
//		strcpy_s(_model, vel, model);
//	}
//
//	Uredjaj(const Uredjaj& u) {
//		int vel = strlen(u._proizvodjac) + 1;
//		_proizvodjac = new char[vel];
//		strcpy_s(_proizvodjac, vel, u._proizvodjac);
//		vel = strlen(u._model) + 1;
//		_model = new char[vel];
//		strcpy_s(_model, vel, u._model);
//	}
//	~Uredjaj()
//	{
//		delete[] _proizvodjac; _proizvodjac = nullptr;
//		delete[] _model; _model = nullptr;
//	}
//	friend ostream& operator<<(ostream& COUT, Uredjaj& obj)
//	{
//		COUT << obj._proizvodjac << "." << obj._model << endl;
//		return COUT;
//	}
//};
//
//class Printer:public Uredjaj
//{
//	FITKolekcija<DatumVrijeme, Dokument> _printaniDokumenti;
//	vector<string> _zabranjeneRijeci;
//public:
//	Printer(const char* proizv, const char* model):Uredjaj(proizv,model) {}
//	Printer(const Printer& p) :Uredjaj(p), _printaniDokumenti(p._printaniDokumenti), _zabranjeneRijeci(p._zabranjeneRijeci) {}
//
//	FITKolekcija<DatumVrijeme, Dokument>& GetPrintaniDokumenti() { return _printaniDokumenti; };
//	vector<string>& GetZabranjeneRijeci() { return _zabranjeneRijeci; };
//
//	void DodajZabranjenuRijec(string rijec) {
//		for (vector<string>::iterator i = _zabranjeneRijeci.begin(); i!= _zabranjeneRijeci.end(); i++)
//		{
//			if (*i == rijec)
//				return;
//		}
//		_zabranjeneRijeci.push_back(rijec);
//	}
//
//	void Printaj(DatumVrijeme dat, Dokument doku) {
//		_printaniDokumenti.Dodaj(dat, doku);
//		
//		if (!regex_match(doku.GetNaziv(), regex("([A-za-z]{5,15})[.](pdf|doc|txt|html)")))
//			throw exception("Naziv nije u ispravnom formatu!");
//
//		for (size_t i = 0; i < _zabranjeneRijeci.size(); i++) // mogli smo iteratorom takoder ici
//		{
//			if (doku.GetSadrzaj().find(_zabranjeneRijeci[i]) != string::npos)
//				//ako se u sadrzaju finda zabranjena rijec a razlicita je od -1 baci izuzetak 
//				//--- npos predstavlja -1(not found, ali je ovo puno prilagodljvije) koristi se sa find---
//				throw exception("U sadrzaju postoje zabranjene rijeci!");
//		}
//	}
//
//	int GetProsjecanBrojStranicaPoDatumu(DatumVrijeme d) {
//		float ukupno_stranica = 0, printanih_stranica = 0;
//		for (size_t i = 0; i < _printaniDokumenti.GetTrenutno(); i++)
//		{
//			if (_printaniDokumenti.GetT1()[i] == d) {
//				bool printaj = true;
//				if (!regex_match(_printaniDokumenti.GetT2()[i].GetNaziv(), regex("([A-Za-z]{5,15})(\\.)(doc|txt|pdf|html)"))) {
//					printaj = false;
//				}
//				for (vector<string>::iterator j = _zabranjeneRijeci.begin(); j != _zabranjeneRijeci.end(); j++)
//				{
//					if (_printaniDokumenti.GetT2()[i].GetSadrzaj().find(*j) != string::npos) {
//						printaj = true;
//						break;
//					}
//				}
//				if (printaj) {
//					ukupno_stranica += _printaniDokumenti.GetT2()[i].GetBrojStranica();
//					printanih_stranica += _printaniDokumenti.GetT2()[i].GetBrojStranica();
//				}
//				else {
//					ukupno_stranica += _printaniDokumenti.GetT2()[i].GetBrojStranica();
//				}
//			}
//		}
//		if (ukupno_stranica != 0)
//			return printanih_stranica / ukupno_stranica;
//		return 0;
//	}
//
//	friend ostream& operator<<(ostream& o, Printer& p) {
//		o << *dynamic_cast<Uredjaj*>(&p) << endl; // really damn al eto 
//		o << "Printani dokumenti" << endl;
//		for (size_t i = 0; i < p._printaniDokumenti.GetTrenutno(); i++)
//			o << p._printaniDokumenti.GetT2()[i].GetNaziv() << endl;
//		o << "Zabranjene rijeci: " << endl;
//		for (vector<string>::iterator i = p._zabranjeneRijeci.begin(); i != p._zabranjeneRijeci.end(); i++)
//			o << *i << endl;
//		return o;
//	}
//
//	void UkloniDokumente() {// mozemo sve iz printaj uslove uzet
//		FITKolekcija<DatumVrijeme, Dokument> f;
//		bool ukloni = false;
//		for (size_t i = 0; i < _printaniDokumenti.GetTrenutno(); i++)
//		{
//			ukloni = false;
//			if (!regex_match(_printaniDokumenti.GetT2()[i].GetNaziv(), regex("([A-Za-z]{5,15})(\\.)(doc|txt|pdf|html)"))) {
//				ukloni = true;
//			}
//			for (vector<string>::iterator j = _zabranjeneRijeci.begin(); j != _zabranjeneRijeci.end(); j++)
//			{
//				if (_printaniDokumenti.GetT2()[i].GetSadrzaj().find(*j) != string::npos) {
//					ukloni = true;
//					break;
//				}
//			}
//			if (!ukloni) {
//				f.Dodaj(_printaniDokumenti.GetT1()[i], _printaniDokumenti.GetT2()[i]);
//			}
//		}
//		_printaniDokumenti = f;
//	}
//	
//};
//
//void main()
//{
//	/****************************************************************************
//	// 1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	// 2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR
//	//    ÆE BITI OZNACENO KAO "RE"
//	// 3. SPAŠAVAJTE PROJEKAT KAKO BI SE SPRIJEÈILO GUBLJENJE URAÐENOG ZADATKA
//	// 4. PROGRAMSKI CODE SE TAKOÐER NALAZI U FAJLU CODE.TXT
//	// 5. NAZIVI FUNKCIJA, TE BROJ I TIP PARAMETARA MORAJU BITI IDENTIÈNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U,
//	//    OSIM U SLUÈAJU DA POSTOJI ADEKVATAN RAZLOG ZA NJIHOVU MODIFIKACIJU. OSTALE, POMOÆNE FUNKCIJE MOŽETE
//	//    IMENOVATI I DODAVATI PO ŽELJI.
//	// 6. IZUZETAK BACITE U FUNKCIJAMA U KOJIMA JE TO NAZNAÈENO.
//	****************************************************************************/
//#pragma region TestiranjeDatumVrijeme
//	DatumVrijeme danas(1, 2, 2017, 10, 15);
//	DatumVrijeme sutra(danas);
//	DatumVrijeme prekosutra;
//	prekosutra = danas;
//	cout << danas << endl << sutra << endl << prekosutra << crt;
//#pragma endregion
//#pragma region FITKolekcija
//	int v6 = 6, v13 = 13, v32 = 32, v63 = 63, v98 = 98, v109 = 109, v196 = 196;
//
//	FITKolekcija<int, int> brojevi;
//	brojevi.Dodaj(v196, v6);
//	brojevi.Dodaj(v13, v32);
//	brojevi.Dodaj(v98, v196);
//	brojevi.Dodaj(v63, v13);
//	brojevi.Dodaj(v98, v196);
//	brojevi.Dodaj(v196, v6);
//
//	cout << brojevi << crt;
//	////SORTIRANJE ÈLANOVA KOLEKCIJE SE VRŠI U RASTUÆEM REDOSLIJEDU NA OSNOVU VRIJEDNOSTI ELEMENTA TIPA T1
//	brojevi.Sortiraj();
//	cout << brojevi << crt;
//	////BROJ 2 SE ODNOSI NA LOKACIJU/INDEKS UNUTAR LISTE NA KOJI JE POTREBNO DODATI NOVE ELEMENTE
//	brojevi.DodajNaLokaciju(v109, v6, 2);
//	cout << brojevi << crt;
//	brojevi.Sortiraj();
//	cout << brojevi << crt;
//	//// METODA GetJedinstveni VRAÆA LISTU JEDINSTVENIH ELEMENATA TJ. ELEMENATA KOJI NE SADRŽE DUPLIKATE 
//	//// (POJAM DUPLIKAT SE ODNOSI NA ISTE VRIJEDNOSTI ELEMENATA T1 I T2). ELEMENTI KOJI SE DUPLIRAJU SE U 
//	//// OVOJ LISTI TREBAJU POJAVITI SAMO JEDNOM.
//	FITKolekcija<int, int>* jedinstveni = brojevi.GetJedinstveni();
//	cout << *jedinstveni << crt;
//	*jedinstveni = brojevi;
//	cout << *jedinstveni << crt;
//
//	Dokument ispitPRIII(DOC, "ispitPRIII.doc");
//	////BROJ STRANICA DOKUMENTA SE AUTOMATSKI ODREÐUJE PRILIKOM DODAVANJA SADRŽAJA. ZA POTREBE ISPITA PRETPOSTAVLJAMO
//	////DA NA JEDNU STRANICU MOŽE STATI 30 ZNAKOVA UKLJUÈUJUÆI I RAZMAKE
//	ispitPRIII.DodajSadrzaj("NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR ÆE BITI OZNACENO KAO RE");
//	cout << "Broj stranica -> " << ispitPRIII.GetBrojStranica() << endl;
//	Dokument ispitBaze(DOC, "ispitBaze.doc");
//	ispitBaze.DodajSadrzaj("PROGRAMSKI CODE SE TAKOÐER NALAZI U FAJLU CODE.TXT");
//	cout << ispitBaze << endl;//ISPISUJE SVE DOSTUPNE PODATKE O DOKUMENTU
//
//	Printer hp3200("HP", "3200");
//	////PRINTER NEÆE DOZVOLITI PRINTANJE DOKUMENATA U ÈIJEM SADRŽAJU SE NALAZI NEKA OD ZABRANJENIH RIJEÈI
//	hp3200.DodajZabranjenuRijec("RE");// :)
//	hp3200.DodajZabranjenuRijec("RAT");
//	hp3200.DodajZabranjenuRijec("UBITI");
//	hp3200.DodajZabranjenuRijec("RE");// ONEMOGUÆITI PONAVLJANJE ZABRANJENIH RIJEÈI, KORISTITI ITERATORE
//	hp3200.DodajZabranjenuRijec("MRZITI");
//	try
//	{
//	//	// DA BI PRINTER ISPRINTAO NEKI DOKUMENT MORAJU BITI ZADOVOLJENA SLJEDEÆA PRAVILA:
//	//	// 1. NAZIV DOKUMENTA MORA BITI U SLJEDEÆEM FORMATU npr: ispitPRIII.doc
//	//	// NAZIV DOKUMENTA MOŽE SADRŽAVATI SAMO SLOVA (NAJMANJE 5, NAJVIŠE 15), A EKSTENZIJA MOŽE 
//	//	// BITI SAMO NEKA OD DOZVOLJENIH VRSTOM DOKUMENTA (vjerovatno regexom se misli uradit)
//	//	// 2. SADRŽAJ DOKUMENTA U SEBI NE SMIJE POSJEDOVATI NITI JEDNU ZABRANJENU RIJEÈ
//	//	// UKOLIKO NEKI OD NAVEDENIH USLOVA NIJE ZADOVOLJEN FUNKCIJA TREBA DA BACI EXCEPTION SA 
//	//	// ODGOVARAJUÆOM PORUKOM, ALI ÆE DOKUMENT BITI POHRANJEN U KOLEKCIJU _printaniDokumenti. 
//	//	// UKOLIKO DOKUMENT ISPUNJAVA SVE USLOVE ZA PRINTANJE POTREBNO JE NA KONZOLU ISPISATI 
//	//	// SADRŽAJ DOKUMENTA KOJI SE PRINTA
//
//		hp3200.Printaj(danas, ispitPRIII);
//		hp3200.Printaj(danas, ispitBaze);
//
//
//		// IMPLEMENTIRATI PRINTANJE U ZASEBNIM NITIMA UZ KORIŠTENJE sleep_for FUNKCIJE
//		// VODITI RAÈUNA O DIJELJENJU ZAJEDNIÈKIH RESURSA
//	}
//	catch (exception& err)
//	{
//		cout << err.what() << endl;
//	}
//
//	////KOD POREÐENJA DATUMA PRINTANJA NIJE POTREBNO POREDITI MINUTE, SAMO DATUM I SATE
//	cout << "Prosjecan broj printanih stranica za " << danas << " je -> " << hp3200.GetProsjecanBrojStranicaPoDatumu(danas) << crt;
//	//cout << "Najcesce koristena zabranjena rijec je -> " << hp3200.GetTopZabranjenuRijec() << crt;
//
//	Printer hp4000(hp3200);
//	cout << "Prosjecan broj printanih stranica za " << danas << " je -> " << hp4000.GetProsjecanBrojStranicaPoDatumu(danas) << crt;
//	//cout << "Najcesce koristena zabranjena rijec je -> " << hp4000.GetTopZabranjenuRijec() << crt;
//	hp4000.UkloniDokumente();//UKLANJA SVE DOKUMENTE KOJI NISU ZADOVOLJILI USLOVE ZA PRINTANJE
//	cout << hp4000 << crt;
//
//#pragma endregion//}

//v 2.0

//#include <iostream>
//#include<vector>
//#include<string>
//#include<iterator>
//#include<regex>
//#include<thread>
//#include<mutex>
//using namespace std;
//
//const char* crt = "\n---------------------------------------\n";
//
//class DatumVrijeme
//{
//	int* _dan, * _mjesec, * _godina, * _sati, * _minuti;
//public:
//	DatumVrijeme(int dan = 1, int mjesec = 1, int godina = 2000, int sati = 0, int minuti = 0)
//	{
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//		_sati = new int(sati);
//		_minuti = new int(minuti);
//	}
//
//	DatumVrijeme(const DatumVrijeme& dat) {
//		_dan = new int(*dat._dan);
//		_mjesec = new int(*dat._mjesec);
//		_godina = new int(*dat._godina);
//		_sati = new int(*dat._sati);
//		_minuti = new int(*dat._minuti);
//	}
//
//	~DatumVrijeme()
//	{
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//		delete _sati; _sati = nullptr;
//		delete _minuti; _minuti = nullptr;
//	}
//	friend ostream& operator<< (ostream& COUT, DatumVrijeme& obj)
//	{
//		COUT << *obj._dan << "." << *obj._mjesec << "." << *obj._godina << " " << *obj._sati << ":" << *obj._minuti;
//		return COUT;
//	}
//
//	void operator=(const DatumVrijeme& dat) {
//		if (this != &dat) {
//			*_dan = *dat._dan;
//			*_mjesec= *dat._mjesec;
//			*_godina = *dat._godina;
//			*_sati= *dat._sati;
//			*_minuti = *dat._minuti;
//		}
//	}
//
//	bool operator==(const DatumVrijeme& d) {
//		return *_dan == *d._dan && *_mjesec == *d._mjesec && *_godina == *d._godina && *_sati == *d._sati;
//	}
//};
//
//template<class T1, class T2 = int>
//class FITKolekcija
//{
//	T1* _elementi1;
//	T2* _elementi2;
//	int _trenutno;
//public:
//	FITKolekcija()
//	{
//		_elementi1 = nullptr;
//		_elementi2 = nullptr;
//		_trenutno = 0;
//	}
//	FITKolekcija(const FITKolekcija& kol) {
//		_trenutno = kol._trenutno;
//		_elementi1 = new T1[kol._trenutno];
//		_elementi2 = new T2[kol._trenutno];
//		for (size_t i = 0; i < _trenutno; i++)
//		{
//			_elementi1[i] = kol._elementi1[i];
//			_elementi2[i] = kol._elementi2[i];
//		}
//	}
//	~FITKolekcija()
//	{
//		delete[] _elementi1; _elementi1 = nullptr;
//		delete[] _elementi2; _elementi2 = nullptr;
//	}
//	T1* GetT1()const { return _elementi1; }
//	T2* GetT2()const { return _elementi2; }
//	int GetTrenutno() const { return _trenutno; }
//
//	void Dodaj(T1 el1, T2 el2) {
//
//		T1* temp1 = new T1[_trenutno + 1];
//		T2* temp2 = new T2[_trenutno + 1];
//		for (size_t i = 0; i < _trenutno; i++)
//		{
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//		delete[]_elementi1;
//		delete[]_elementi2;
//		temp1[_trenutno] = el1;
//		temp2[_trenutno] = el2;
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//		_trenutno++;
//	}
//
//	void Sortiraj() {
//
//		bool sort = true;
//		while (sort)
//		{
//			sort = false;
//			for (size_t i = 0; i < _trenutno - 1; i++)
//			{
//				if (_elementi1[i] > _elementi1[i + 1])
//				{
//					T1 temp1 = _elementi1[i];
//					T2 temp2 = _elementi2[i];
//					_elementi1[i] = _elementi1[i + 1];
//					_elementi2[i] = _elementi2[i + 1];
//					_elementi1[i + 1] = temp1;
//					_elementi2[i + 1] = temp2;
//					sort = true;
//				}
//			}
//		}
//	}
//
//	bool DodajNaLokaciju(T1 el1, T2 el2, int indeks) {
//		if (indeks < 0 || indeks >= _trenutno)
//			return false;
//
//		Dodaj(el1, el2);
//		swap(_elementi1[_trenutno - 1], _elementi1[indeks]); // zamjeni zadnji i element na drugoj poziciji
//		swap(_elementi2[_trenutno - 1], _elementi2[indeks]);
//		return true;
//	}
//
//	FITKolekcija<int, int>* GetJedinstveni() {
//		FITKolekcija<int, int>* el = new FITKolekcija<int, int>;
//		
//		for (size_t i = 0; i < _trenutno; i++)
//		{
//			bool dodaj = false;
//			for (size_t j = 0; j < el->GetTrenutno(); j++)
//			{
//				if (_elementi1[i] == el->GetT1()[j] && _elementi2[i] == el->GetT2()[j])
//					dodaj = true;
//			}
//			if (!dodaj)
//				el->Dodaj(_elementi1[i], _elementi2[i]);
//		}
//		return el;
//	}
//
//	void operator=(const FITKolekcija& kol) {
//		if (this != &kol) {
//			delete[]_elementi1; 
//			delete[]_elementi2;
//			_trenutno = kol._trenutno;
//			_elementi1= new T1[kol._trenutno];
//			_elementi2 = new T2[kol._trenutno];
//			for (size_t i = 0; i < _trenutno; i++)
//			{
//				_elementi1[i] = kol._elementi1[i];
//				_elementi2[i] = kol._elementi2[i];
//			}
//		}
//	}
//
//	friend ostream& operator<< (ostream& COUT, FITKolekcija& obj)
//	{
//		for (size_t i = 0; i < obj._trenutno; i++)
//			COUT << obj._elementi1[i] << " " << obj._elementi2[i] << endl;
//		return COUT;
//	}
//};
//
//enum vrstaDokumenta { PDF, DOC, TXT, HTML };
//
//class Dokument
//{
//	vrstaDokumenta _vrsta;
//	string _naziv;
//	string _sadrzaj;
//	int _brojStranica;
//public:
//	Dokument() { _brojStranica = 0; _naziv = ""; _sadrzaj = ""; }
//
//	Dokument(vrstaDokumenta vrsta, string naziv)
//	{
//		_naziv = naziv; _vrsta = vrsta; _brojStranica = 0;
//	}
//	string GetNaziv() { return _naziv; };
//	string GetSadrzaj() { return _sadrzaj; };
//	vrstaDokumenta GetVrsta() { return _vrsta; };
//	void UvecajBrojStranica() { _brojStranica++; }
//	int GetBrojStranica() { return _brojStranica; }
//	
//	void DodajSadrzaj(string sadrzaj) {
//		_sadrzaj += sadrzaj;
//		_brojStranica = _sadrzaj.length() / 30;
//	}
//	
//	friend ostream& operator<<(ostream& COUT, Dokument& obj)
//	{
//		COUT << obj._naziv << "." << obj._vrsta << " (" << obj._brojStranica << ")\n" << obj._sadrzaj << endl;
//		return COUT;
//	}
//};
//
//class Uredjaj
//{
//protected:
//	char* _proizvodjac;
//	char* _model;
//public:
//	Uredjaj(const char* proizvodjac, const char* model)
//	{
//		int vel = strlen(proizvodjac) + 1;
//		_proizvodjac = new char[vel];
//		strcpy_s(_proizvodjac, vel, proizvodjac);
//		vel = strlen(model) + 1;
//		_model = new char[vel];
//		strcpy_s(_model, vel, model);
//	}
//
//	Uredjaj(const Uredjaj& ur) {
//		int vel = strlen(ur._proizvodjac) + 1;
//		_proizvodjac = new char[vel];
//		strcpy_s(_proizvodjac, vel, ur._proizvodjac);
//		vel = strlen(ur._model) + 1;
//		_model = new char[vel];
//		strcpy_s(_model, vel, ur._model);
//	}
//
//	~Uredjaj()
//	{
//		delete[] _proizvodjac; _proizvodjac = nullptr;
//		delete[] _model; _model = nullptr;
//	}
//	friend ostream& operator<<(ostream& COUT, Uredjaj& obj)
//	{
//		COUT << obj._proizvodjac << "." << obj._model << endl;
//		return COUT;
//	}
//
//};
//
//mutex m;
//void print(string text) {
//	lock_guard<mutex>guard(m);
//	cout << text << endl;
//}
//class Printer:public Uredjaj
//{
//	FITKolekcija<DatumVrijeme, Dokument> _printaniDokumenti;
//	vector<string> _zabranjeneRijeci;
//public:
//	Printer(const char* proizv, const char* model) :Uredjaj(proizv, model) {}; // ODE LI U NULLPTR SIGURNO SAM PROSLIJEDIO PRAZNE A NE PROSLIJEDENE VRIJEDNOSTI
//	Printer(const Printer& pri) :Uredjaj(pri._proizvodjac, pri._model), _printaniDokumenti(pri._printaniDokumenti), _zabranjeneRijeci(pri._zabranjeneRijeci) {};
//	
//	FITKolekcija<DatumVrijeme, Dokument>& GetPrintaniDokumenti() { return _printaniDokumenti; };
//	vector<string>& GetZabranjeneRijeci() { return _zabranjeneRijeci; };
//	
//	void DodajZabranjenuRijec(string rijec) {
//		for (vector<string>::iterator i = _zabranjeneRijeci.begin(); i != _zabranjeneRijeci.end(); i++)
//		{
//			if (*i == rijec)
//				return;
//		}
//		_zabranjeneRijeci.push_back(rijec);
//	}
//
//	void Printaj(DatumVrijeme dat, Dokument doku) {
//		_printaniDokumenti.Dodaj(dat, doku);
//		if (!regex_match(doku.GetNaziv(), regex("([A-Za-z]{5,15})([.])(pdf|doc|html|txt)")))
//			throw exception("Naziv dokumenta nije u odgovarajucem formatu");
//		for (vector<string>::iterator i = _zabranjeneRijeci.begin(); i != _zabranjeneRijeci.end(); i++)
//		{
//			if (doku.GetSadrzaj().find(*i) != string::npos)
//				throw exception("Sadrzaj dokumenta sadrzi zabranjenu/e rijeci/i");
//		}
//
//		thread t(print, doku.GetSadrzaj());
//		t.detach();
//	}
//
//	int GetProsjecanBrojStranicaPoDatumu(DatumVrijeme dat) {
//		float ukupno = 0, printanihStr = 0;
//
//		for (size_t i = 0; i < _printaniDokumenti.GetTrenutno(); i++)
//		{
//			if (_printaniDokumenti.GetT1()[i] == dat) {
//				bool print = true;
//				if (!regex_match(_printaniDokumenti.GetT2()[i].GetNaziv(), regex("([A-Za-z]{5,15})([.])(pdf|doc|html|txt)")))
//					print = false;
//				for (vector<string>::iterator j = _zabranjeneRijeci.begin(); j != _zabranjeneRijeci.end(); j++)
//				{
//					if (_printaniDokumenti.GetT2()[i].GetNaziv().find(*j) != string::npos)
//						print = true;
//					break;
//				}
//			}
//			if (print) {
//				ukupno += _printaniDokumenti.GetT2()[i].GetBrojStranica();
//				printanihStr = _printaniDokumenti.GetT2()[i].GetBrojStranica();
//			}
//			else
//				ukupno += _printaniDokumenti.GetT2()[i].GetBrojStranica();
//		}
//		if (ukupno > 0)
//			return printanihStr/ukupno;
//		return 0;
//	}
//
//	friend ostream& operator<<(ostream& cout, Printer& pri) {
//		cout << *dynamic_cast<Uredjaj*>(&pri) << endl;
//		cout << "PRINTANI DOKUMENTI: " << endl;
//		for (size_t i = 0; i < pri._printaniDokumenti.GetTrenutno(); i++)
//			cout << pri._printaniDokumenti.GetT2()[i].GetNaziv() << endl;
//		cout << endl;
//		cout << "ZABRANJENE RIJECI" << endl;
//
//		for (vector<string>::iterator j = pri._zabranjeneRijeci.begin(); j != pri._zabranjeneRijeci.end(); j++)
//					cout << *j << endl;
//		return cout;
//	}
//};
//
//void main()
//{
//	/****************************************************************************
//	// 1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	// 2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR
//	//    ÆE BITI OZNACENO KAO "RE"
//	// 3. SPAŠAVAJTE PROJEKAT KAKO BI SE SPRIJEÈILO GUBLJENJE URAÐENOG ZADATKA
//	// 4. PROGRAMSKI CODE SE TAKOÐER NALAZI U FAJLU CODE.TXT
//	// 5. NAZIVI FUNKCIJA, TE BROJ I TIP PARAMETARA MORAJU BITI IDENTIÈNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U,
//	//    OSIM U SLUÈAJU DA POSTOJI ADEKVATAN RAZLOG ZA NJIHOVU MODIFIKACIJU. OSTALE, POMOÆNE FUNKCIJE MOŽETE
//	//    IMENOVATI I DODAVATI PO ŽELJI.
//	// 6. IZUZETAK BACITE U FUNKCIJAMA U KOJIMA JE TO NAZNAÈENO.
//	****************************************************************************/
//#pragma region TestiranjeDatumVrijeme
//	DatumVrijeme danas(1, 2, 2017, 10, 15);
//	DatumVrijeme sutra(danas);
//	DatumVrijeme prekosutra;
//	prekosutra = danas;
//	cout << danas << endl << sutra << endl << prekosutra << crt;
//#pragma endregion
//#pragma region FITKolekcija
//	int v6 = 6, v13 = 13, v32 = 32, v63 = 63, v98 = 98, v109 = 109, v196 = 196;
//
//	FITKolekcija<int, int> brojevi;
//	brojevi.Dodaj(v196, v6);
//	brojevi.Dodaj(v13, v32);
//	brojevi.Dodaj(v98, v196);
//	brojevi.Dodaj(v63, v13);
//	brojevi.Dodaj(v98, v196);
//	brojevi.Dodaj(v196, v6);
//
//	cout << brojevi << crt;
//	////SORTIRANJE ÈLANOVA KOLEKCIJE SE VRŠI U RASTUÆEM REDOSLIJEDU NA OSNOVU VRIJEDNOSTI ELEMENTA TIPA T1
//	brojevi.Sortiraj();
//	cout << brojevi << crt;
//	////BROJ 2 SE ODNOSI NA LOKACIJU/INDEKS UNUTAR LISTE NA KOJI JE POTREBNO DODATI NOVE ELEMENTE
//	brojevi.DodajNaLokaciju(v109, v6, 2);
//	cout << brojevi << crt;
//	brojevi.Sortiraj();
//	cout << brojevi << crt;
//	// METODA GetJedinstveni VRAÆA LISTU JEDINSTVENIH ELEMENATA TJ. ELEMENATA KOJI NE SADRŽE DUPLIKATE 
//	// (POJAM DUPLIKAT SE ODNOSI NA ISTE VRIJEDNOSTI ELEMENATA T1 I T2). ELEMENTI KOJI SE DUPLIRAJU SE U 
//	// OVOJ LISTI TREBAJU POJAVITI SAMO JEDNOM.
//	FITKolekcija<int, int>* jedinstveni = brojevi.GetJedinstveni();
//	cout << *jedinstveni << crt;
//	*jedinstveni = brojevi;
//	cout << *jedinstveni << crt;
//
//	Dokument ispitPRIII(DOC, "ispitPRIII.doc");
//	////BROJ STRANICA DOKUMENTA SE AUTOMATSKI ODREÐUJE PRILIKOM DODAVANJA SADRŽAJA. ZA POTREBE ISPITA PRETPOSTAVLJAMO
//	////DA NA JEDNU STRANICU MOŽE STATI 30 ZNAKOVA UKLJUÈUJUÆI I RAZMAKE
//	ispitPRIII.DodajSadrzaj("NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR ÆE BITI OZNACENO KAO RE");
//	cout << "Broj stranica -> " << ispitPRIII.GetBrojStranica() << endl;
//	Dokument ispitBaze(DOC, "ispitBaze.doc");
//	ispitBaze.DodajSadrzaj("PROGRAMSKI CODE SE TAKOÐER NALAZI U FAJLU CODE.TXT");
//	cout << ispitBaze << endl;//ISPISUJE SVE DOSTUPNE PODATKE O DOKUMENTU
//
//	Printer hp3200("HP", "3200");
//	////PRINTER NEÆE DOZVOLITI PRINTANJE DOKUMENATA U ÈIJEM SADRŽAJU SE NALAZI NEKA OD ZABRANJENIH RIJEÈI
//	hp3200.DodajZabranjenuRijec("RE");// :)
//	hp3200.DodajZabranjenuRijec("RAT");
//	hp3200.DodajZabranjenuRijec("UBITI");
//	hp3200.DodajZabranjenuRijec("RE");// ONEMOGUÆITI PONAVLJANJE ZABRANJENIH RIJEÈI, KORISTITI ITERATORE
//	hp3200.DodajZabranjenuRijec("MRZITI");
//	try
//	{
//		// DA BI PRINTER ISPRINTAO NEKI DOKUMENT MORAJU BITI ZADOVOLJENA SLJEDEÆA PRAVILA:
//		// 1. NAZIV DOKUMENTA MORA BITI U SLJEDEÆEM FORMATU npr: ispitPRIII.doc
//		// NAZIV DOKUMENTA MOŽE SADRŽAVATI SAMO SLOVA (NAJMANJE 5, NAJVIŠE 15), A EKSTENZIJA MOŽE 
//		// BITI SAMO NEKA OD DOZVOLJENIH VRSTOMDOKUMENTA
//		// 2. SADRŽAJ DOKUMENTA U SEBI NE SMIJE POSJEDOVATI NITI JEDNU ZABRANJENU RIJEÈ
//		// UKOLIKO NEKI OD NAVEDENIH USLOVA NIJE ZADOVOLJEN FUNKCIJA TREBA DA BACI EXCEPTION SA 
//		// ODGOVARAJUÆOM PORUKOM, ALI ÆE DOKUMENT BITI POHRANJEN U KOLEKCIJU _printaniDokumenti. 
//		// UKOLIKO DOKUMENT ISPUNJAVA SVE USLOVE ZA PRINTANJE POTREBNO JE NA KONZOLU ISPISATI 
//		// SADRŽAJ DOKUMENTA KOJI SE PRINTA
//
//		hp3200.Printaj(danas, ispitPRIII);
//		hp3200.Printaj(danas, ispitBaze);
//
//
//		// IMPLEMENTIRATI PRINTANJE U ZASEBNIM NITIMA UZ KORIŠTENJE sleep_for FUNKCIJE
//		// VODITI RAÈUNA O DIJELJENJU ZAJEDNIÈKIH RESURSA
//	}
//	catch (exception& err)
//	{
//		cout << err.what() << endl;
//	}
//
//	//KOD POREÐENJA DATUMA PRINTANJA NIJE POTREBNO POREDITI MINUTE, SAMO DATUM I SATE
//	cout << "Prosjecan broj printanih stranica za " << danas << " je -> " << hp3200.GetProsjecanBrojStranicaPoDatumu(danas) << crt;
//	//cout << "Najcesce koristena zabranjena rijec je -> " << hp3200.GetTopZabranjenuRijec() << crt;
//
//	Printer hp4000(hp3200);
//	cout << "Prosjecan broj printanih stranica za " << danas << " je -> " << hp4000.GetProsjecanBrojStranicaPoDatumu(danas) << crt;
//	//cout << "Najcesce koristena zabranjena rijec je -> " << hp4000.GetTopZabranjenuRijec() << crt;
//	//hp4000.UkloniDokumente();//UKLANJA SVE DOKUMENTE KOJI NISU ZADOVOLJILI USLOVE ZA PRINTANJE
//	cout << hp4000 << crt;
//
//#pragma endregion
//}


// predmeti razredi


//#include<iostream>
//#include<string>
//#include<vector>
//#include<regex>
//using namespace std;
//enum Predmeti { Matematika, Historija, Geografia, Hemija, Biologija, Engleski, Muzicko, Fizicko };
//enum Razredi { I1, I2, I3, II1, II2, II3, III1, III2, III3, IV1, IV2, IV3 };
//const char* ispisPredmeti[] = { "Matematika", "Historija", "Geografia", "Hemija", "Biologija", "Engleski", "Muzicko", "Fizicko" };
//const char* ispisRazredi[] = { "I1", "I2", "I3", "II1", "II2", "II3", "III1", "III2", "III3", "IV1", "IV2", "IV3" };
//const char* crt = "\n--------------------------------------\n";
//
//bool ProvjeriValidnostBrojaTelefona(string telefon) {//globalna funkcija
//	/*
//	broj telefona treba biti u formatu: +387(61)-222-333
//	*/
//	return regex_match(telefon, regex("([+])(\\d{3})([(])(\\d{2})([)])([-])(\\d{3})([-])(\\d{3})"));
//}
//
//template<class T1, class T2>
//class Kolekcija {
//	T1* _elementi1;
//	T2* _elementi2;
//	int _trenutno;
//public:
//	Kolekcija()
//	{
//		_elementi1 = nullptr;
//		_elementi2 = nullptr;
//		_trenutno = 0;
//	}
//
//	Kolekcija(const Kolekcija& kol) {
//		_trenutno = kol._trenutno;
//		_elementi1 = new T1[kol._trenutno];
//		_elementi2 = new T2[kol._trenutno];
//		for (size_t i = 0; i < kol._trenutno; i++)
//		{
//			_elementi1[i] = kol._elementi1[i];
//			_elementi2[i] = kol._elementi2[i];
//		}
//	}
//	~Kolekcija()
//	{
//		delete[]_elementi1;
//		delete[]_elementi2;
//	}
//	int GetTrenutno()const { return _trenutno; }
//	int GetElement1(int el1)const { return _elementi1[el1]; }
//	int GetElement2(int el2)const { return _elementi2[el2]; }
//
//	void AddElement(T1 el1, T2 el2) {
//
//		T1* temp1 = new T1[_trenutno + 1];
//		T2* temp2 = new T2[_trenutno + 1];
//		for (size_t i = 0; i < _trenutno; i++)
//		{
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//		temp1[_trenutno] = el1;
//		temp2[_trenutno] = el2;
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//		_trenutno++;
//	}
//
//	void RemoveElement(int lokacija) {
//		for (size_t i = lokacija; i < _trenutno-1; i++)
//		{
//			_elementi1[i] = _elementi1[i + 1];
//			_elementi2[i] = _elementi2[i + 1];
//		}
//		_trenutno--;
//	}
//
//	void operator=(const Kolekcija& kol) {
//		if (this != &kol) {
//			delete[]_elementi1;
//			delete[]_elementi2;
//			_trenutno = kol._trenutno;
//			_elementi1 = new T1[kol._trenutno];
//			_elementi2 = new T2[kol._trenutno];
//			for (size_t i = 0; i < kol._trenutno; i++)
//			{
//				_elementi1[i] = kol._elementi1[i];
//				_elementi2[i] = kol._elementi2[i];
//			}
//		}
//
//
//	}
//
//	friend ostream& operator<< (ostream& cout, const Kolekcija& kol) {
//		for (size_t i = 0; i < kol.GetTrenutno(); i++)
//			cout << kol.GetElement1(i)<< " " << kol.GetElement2(i)<< endl;
//		return cout;
//	}
//
//};
//class Datum {
//	int* _dan, * _mjesec, * _godina;
//public:
//	Datum(int dan = 1, int mjesec = 1, int godina = 2000) {
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//	}
//
//	Datum(const Datum& obj) {
//		_dan = new int(*obj._dan);
//		_mjesec = new int(*obj._mjesec);
//		_godina = new int(*obj._godina);
//	}
//
//	~Datum() {
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//	}
//
//	void operator=(const Datum& dat) {
//		if (this != &dat) {
//			*_dan = *dat._dan;
//			*_mjesec= *dat._mjesec;
//			*_godina = *dat._godina;
//		}
//	}
//
//	friend ostream& operator<< (ostream& COUT, const Datum& obj) {
//		COUT << *obj._dan << " " << *obj._mjesec << " " << *obj._godina;
//		return COUT;
//	}
//};
//class Osoba {
//protected:
//	char* _imePrezime;
//	Datum* _datumRodjenja;
//	string _brojTelefona;
//public:
//	Osoba(const char* imePrezime, Datum datum) {
//		_imePrezime = new char[strlen(imePrezime) + 1];
//		strcpy_s(_imePrezime, strlen(imePrezime) + 1, imePrezime);
//		_datumRodjenja = new Datum(datum);
//		_brojTelefona = "";
//	}
//	Osoba(const Osoba& obj) :_brojTelefona(obj._brojTelefona) {
//		_imePrezime = new char[strlen(obj._imePrezime) + 1];
//		strcpy_s(_imePrezime, strlen(obj._imePrezime) + 1, obj._imePrezime);
//		_datumRodjenja = new Datum(*obj._datumRodjenja);
//	}
//	~Osoba() { delete[]_imePrezime; delete _datumRodjenja; }
//
//	void operator=(const Osoba& os) {
//		if (this != &os) {
//			delete[]_imePrezime;
//			_brojTelefona = os._brojTelefona;
//			_imePrezime = new char[strlen(os._imePrezime) + 1];
//			strcpy_s(_imePrezime, strlen(os._imePrezime) + 1, os._imePrezime);
//			*_datumRodjenja = *os._datumRodjenja;
//		}
//	}
//
//	bool setBrojTelefona(string brojTelefona) {
//		if (ProvjeriValidnostBrojaTelefona(brojTelefona)) {
//			_brojTelefona = brojTelefona;
//			return true;
//		}
//		return false;
//	}
//
//	friend ostream& operator <<(ostream& o, const Osoba& u) {
//		o << "Ime i prezime " << u._imePrezime << " Broj telefona " << u._brojTelefona << "Datum rodjenja " << *u._datumRodjenja;
//		return o;
//	}
//
//};
//
//class Nastavnik :public Osoba {
//	Kolekcija<Predmeti, Razredi>* _predmetiRazredi;
//public:
//	Nastavnik(const char* imePrezime, Datum dat) :Osoba(imePrezime, dat) {
//		_predmetiRazredi = new Kolekcija<Predmeti, Razredi>;
//	}
//
//	Nastavnik(const Nastavnik& nast):Osoba(nast) {
//		_predmetiRazredi = new Kolekcija<Predmeti, Razredi>(*nast._predmetiRazredi);
//	}
//	
//	/*NASTAVNIK MOZE PREDAVATI ISTI PREDMET, ALI TO MORA BITI U RAZLICITIM ODJELJENJIMA
//	I NAJVISE U DVA RAZREDA (NA DVIJE RAZLICITE GODINE)*/
//
//	bool AddPredmetRazred(Predmeti predm, Razredi raz) {
//		int brojRazreda = 0;
//		for (size_t i = 0; i < _predmetiRazredi->GetTrenutno(); i++)
//		{
//			if (_predmetiRazredi->GetElement1(i) == predm && _predmetiRazredi->GetElement2(i) == raz) return false;
//			if (_predmetiRazredi->GetElement1(i) == predm) brojRazreda++;
//		}
//		if (brojRazreda > 2) return false;
//		_predmetiRazredi->AddElement(predm, raz);
//		return true;
//	}
//
//	bool RemovePredmetRazred(Predmeti predm) {
//		for (size_t i = 0; i < _predmetiRazredi->GetTrenutno(); i++)
//		{
//			if (_predmetiRazredi->GetElement1(i) == predm)
//				_predmetiRazredi->RemoveElement(predm);
//			return true;
//		}
//		return false;
//	}
//
//	friend bool operator==(const Nastavnik &nast1, const Nastavnik& nast2) {
//		return strcmp(nast1._imePrezime, nast2._imePrezime) == 0;
//	}
//
//	void operator=(const Nastavnik& nast) {
//		Osoba::operator=(nast);
//		*_predmetiRazredi = *nast._predmetiRazredi;
//	}
//
//	Kolekcija<Predmeti, Razredi>& getPredmetiRazredi() { return *_predmetiRazredi; }
//
//};
//
//class Ucenik : public Osoba {
//	int _brojUDnevniku;
//	Razredi _razred;
//	vector<Nastavnik*> _nastavnici;
//	Kolekcija<Predmeti, int> _predmetiOcjene;
//public:
//	Ucenik(const char* imePrezime, Datum dat, int brojUDnevniku, Razredi raz):Osoba(imePrezime,dat) {
//		_brojUDnevniku = brojUDnevniku;
//		_razred = raz;
//	}
//	Ucenik(const Ucenik& u) :Osoba(u), _brojUDnevniku(u._brojUDnevniku), _razred(u._razred), _nastavnici(u._nastavnici), _predmetiOcjene(u._predmetiOcjene) {}
//	vector<Nastavnik*>& getNastavnici() { return _nastavnici; }
//	Kolekcija<Predmeti, int>& getPredmetiOcjene() { return _predmetiOcjene; }
//	/*ZA USPJESNO DODAVANJE, NASTAVNIK MORA POSJEDOVATI (PREDAVATI) NAJMANJE JEDAN PREDMET U TOM RAZREDU */
//	/*ONEMOGUCITI DODAVANJE ISTIH NASTAVNIKA; POJAM ISTI PODRAZUMIJEVA IDENTICNE VRIJEDNOSTI SVIH ATRIBUTA*/
//	bool AddNastavnik(Nastavnik &n){
//		bool flag = true;
//		for (size_t i = 0; i < n.getPredmetiRazredi().GetTrenutno(); i++)
//		if (n.getPredmetiRazredi().GetElement2(i) == _razred) flag = false;
//		if (flag) return false;
//		_nastavnici.push_back(&n);
//		return true;
//	}
//	bool AddPredmetOcjenu(Predmeti predm, int ocjena) {
//		bool flag = true;
//		for (size_t i = 0; i < _nastavnici.size(); i++)
//		{
//			if (_nastavnici[i]->getPredmetiRazredi().GetElement1(i) == predm) flag == false;
//			if (flag) return false;
//			_predmetiOcjene.AddElement(predm, ocjena);
//			return true;
//		}
//	}
//	friend ostream& operator <<(ostream& o,const Ucenik& u) {
//		o << static_cast<Osoba>(u) << endl; // KADA ZNAMO NA KOJI SE OBJEKAT REFERENCIRAMO KORISTIMO STATIC I SVUGDJE NAM TREBA CONST
//		                                    //U ISPISU GDJE GOD SE ON POZIVA JER ON GARANTUJE TU STATICNOST
//		o << "Broj u dnevniku " << u._brojUDnevniku << endl;
//		o << "Predmeti Ocjene" << endl;
//		o << u._predmetiOcjene << endl;
//		return o;
//	}
//};
//
//
//void main() {
//
//	/****************************************************************************
//	1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR CE BITI OZNACENO KAO "RE"
//	3. SPASAVAJTE PROJEKAT KAKO BI SE SPRIJECILO GUBLJENJE URADJENOG ZADATKA
//	4. PROGRAMSKI CODE SE TAKODJER NALAZI U FAJLU CODE_.TXT
//	5. NAZIV I LISTA PARAMETARA FUNKCIJA MORAJU BITI IDENTIČNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U.
//	6. NIJE POTREBNO BACATI IZUZETKE. SVE FUNKCIJE VRACAJU TRUE ILI FALSE
//	****************************************************************************/
//
//#pragma region TestiranjeDatuma
//	Datum danas(26, 11, 2015);
//	Datum sutra(danas);
//	Datum prekosutra;
//	prekosutra = danas;
//	cout << danas << endl << sutra << endl << prekosutra << crt;
//#pragma endregion
//#pragma region TestiranjeKolekcije
//	Kolekcija<int, int> kolekcija1;
//	int brojElemenata = 15;
//	for (size_t i = 0; i < brojElemenata; i++)
//		kolekcija1.AddElement(i, i);
//	kolekcija1.RemoveElement(0);//uklanja element na osnovu lokacije
//	cout << kolekcija1.GetElement1(0) << " " << kolekcija1.GetElement2(0) << endl;
//	cout << kolekcija1 << endl;
//	Kolekcija<int, int> kolekcija2;
//	kolekcija2 = kolekcija1;
//	cout << kolekcija2 << crt;
//	if (kolekcija1.GetTrenutno() == kolekcija2.GetTrenutno())
//		cout << "ISTI BROJ ELEMENATA" << endl;
//	Kolekcija<int, int> kolekcija3(kolekcija2);
//	cout << kolekcija3 << crt;
//#pragma endregion
//#pragma region TestiranjeNastavnika
//	Nastavnik jasmin("Jasmin Azemovic", Datum(15, 2, 1980));
//	Nastavnik adel("Adel Handzic", Datum(15, 10, 1981));
//	/*NASTAVNIK MOZE PREDAVATI ISTI PREDMET, ALI TO MORA BITI U RAZLICITIM ODJELJENJIMA 
//	I NAJVISE U DVA RAZREDA (NA DVIJE RAZLICITE GODINE)*/
//	if (jasmin.AddPredmetRazred(Matematika, I1))
//		cout << "Predmeti dodan" << endl;
//	if (jasmin.AddPredmetRazred(Historija, I1))
//		cout << "Predmeti dodan" << endl;
//
//	if (jasmin.AddPredmetRazred(Geografia, I1))
//		cout << "Predmeti dodan" << endl;
//
//	if (jasmin.AddPredmetRazred(Geografia, I2))
//		cout << "Predmeti dodan" << endl;
//
//	if (adel.AddPredmetRazred(Historija, III1))
//		cout << "Predmeti dodan" << endl;
//
//	if (adel.RemovePredmetRazred(Historija))
//		cout << "Predmet uklonjen!" << endl;
//
//	Nastavnik goran(adel);
//	if (goran == adel)
//		cout << "Nastavnici identicni" << endl;
//	goran = jasmin;
//	if (goran == jasmin)
//		cout << "Nastavnici identicni" << endl;
//
//	Kolekcija<Predmeti, Razredi>& predmetiRazredi = jasmin.getPredmetiRazredi();
//
//	if (!jasmin.setBrojTelefona("+38761111222"))
//		cout << "Broj telefona nije dodan!" << endl;
//	if (!jasmin.setBrojTelefona("+387-61-111-222"))
//		cout << "Broj telefona nije dodan!" << endl;
//	if (jasmin.setBrojTelefona("+387(61)-111-222"))
//		cout << "Broj telefona uspjesno dodan!" << endl;
//#pragma endregion
//
//#pragma region TestiranjeUcenika
//	Ucenik denis("Denis Music", Datum(8, 10, 1990), 3, III1);
//	Ucenik elmin("Elmin Sudic", Datum(15, 6, 1993), 1, I1);
//	Ucenik adil("Adil Joldic", Datum(13, 8, 1992), 2, II1);
//	/*VODITI RACUNA DA SE DODAJU REFERENCE NA NASTAVNIKE KAKO BI SVI UCENICI DIJELILI ISTE INFORMACIJE O NASTAVNICIMA 
//	U SLUCAJU DA SE NASTAVNIKU DODA NEKI PREDMET*/
//	/*ZA USPJESNO DODAVANJE, NASTAVNIK MORA POSJEDOVATI (PREDAVATI) NAJMANJE JEDAN PREDMET U TOM RAZREDU */
//	if (denis.AddNastavnik(jasmin))
//		cout << "Nastavnik uspjesno dodan" << endl;
//	/*ONEMOGUCITI DODAVANJE ISTIH NASTAVNIKA; POJAM ISTI PODRAZUMIJEVA IDENTICNE VRIJEDNOSTI SVIH ATRIBUTA*/
//	if (denis.AddNastavnik(adel))
//		cout << "Nastavnik uspjesno dodan" << endl;
//	/*DA BI SE DODALA OCJENA ZA ODREDJENI PREDMET UCENIK MORA POSJEDOVATI NASTAVNIKA KOJI PREDAJE TAJ PREDMET*/
//	if (denis.AddPredmetOcjenu(Matematika, 3))
//		cout << "Ocjena uspjesno dodana" << endl;
//	if (denis.AddPredmetOcjenu(Historija, 4))
//		cout << "Ocjena uspjesno dodana" << endl;
//
//	vector<Nastavnik*>& nastavnici = denis.getNastavnici();
//	cout << "Ucenik Denis ima dodijeljena " << nastavnici.size() << " nastavnika" << endl;
//
//	Kolekcija<Predmeti, int>& uspjeh = denis.getPredmetiOcjene();
//	cout << "Denis ima " << uspjeh.GetTrenutno() << " polozenih predmeta" << endl;
//	//cout << "Prosjecna ocjena kod nastavnika Jasmin Azemovic je " << denis.GetProsjekByNastavnik("Jasmin Azemovic") << endl;
//
//	Ucenik denis2(denis);
//	cout << denis2 << endl;
//
//#pragma endregion
//	system("pause");
//}


// vize

//#include<iostream>
//#include<vector>
//#include<string>
//#include<regex>
//#include<thread>
//#include<mutex>
//#include<chrono>
//using namespace std;
//const char* crt = "\n-----------------------------------------------\n";
//
//enum Status { ZAHTJEV_ZAPRIMLJEN, ODUSTAO, ODBIJENA, IZDATA, ISTEKLA, PONISTENA };
//enum Sortiranje { RASTUCI, OPADAJUCI };
//enum Drzava { SAD, AUSTRALIJA, ENGLESKA };
//
//class Datum
//{
//	int* _dan, * _mjesec, * _godina;
//public:
//	Datum(int dan = 1, int mjesec = 1, int godina = 2000)
//	{
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//	}
//	Datum(const Datum& dat) {
//		_dan = new int(*dat._dan);
//		_mjesec = new int(*dat._mjesec);
//		_godina = new int(*dat._godina);
//	}
//	~Datum()
//	{
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//	}
//	friend ostream& operator<< (ostream& COUT, Datum& obj)
//	{
//		COUT << *obj._dan << "." << *obj._mjesec << "." << *obj._godina;
//		return COUT;
//	}
//	void operator=(const Datum& dat) {
//		if (this != &dat) {
//			*_dan = *dat._dan;
//			*_mjesec= *dat._mjesec;
//			*_godina= *dat._godina;
//		}
//	}
//
//	bool operator==(const Datum& dat) {
//		if (*_dan == *dat._dan,
//			*_mjesec == *dat._mjesec,
//			*_godina == *dat._godina) return true;
//		return false;
//	}
//	Datum& operator++() {
//		(*_dan)++;
//		if ((*_mjesec == 1 || *_mjesec == 3 || *_mjesec == 5 || *_mjesec == 7 || *_mjesec == 8 || *_mjesec == 10 || *_mjesec == 12) && *_dan > 31) {
//			*_dan = 1;
//			(*_mjesec)++;
//		}
//		else if ((*_mjesec == 1 || *_mjesec == 3 || *_mjesec == 5 || *_mjesec == 7 || *_mjesec == 8 || *_mjesec == 10 || *_mjesec == 12) && *_dan > 30) {
//			*_dan = 1;
//			*_mjesec = *_mjesec + 1;
//		}
//		else if (*_mjesec == 2 && *_dan > 29 && (*_godina % 4 == 0 && *_godina % 100 != 0 || *_godina % 400 == 0)) {
//			*_dan = 1;
//			*_mjesec = *_mjesec + 1;
//		}
//		else if (*_mjesec == 2 && *_dan > 28 && !(*_godina % 4 == 0 && *_godina % 100 != 0 || *_godina % 400 == 0)) {
//			*_dan = 1;
//			*_mjesec = *_mjesec + 1;
//		}
//
//		if (*_mjesec > 12) {
//			*_mjesec = 1;
//			*_godina = *_godina + 1;
//		}
//		return *this;
//	}
//
//	int getYear() { return *_godina; }
//	bool operator >(const Datum& d) {
//		return (*_dan + *_mjesec * 30 + *_godina * 365) > (*d._dan + *d._mjesec * 30 + *d._godina * 365);
//	}
//};
//
//template<class T1, class T2, int max>
//class FITKolekcija
//{
//	T1* _elementi1[max];
//	T2* _elementi2[max];
//	int _trenutno;
//public:
//	FITKolekcija()
//	{
//		for (size_t i = 0; i < max; i++)
//		{
//			_elementi1[i] = nullptr;
//			_elementi2[i] = nullptr;
//		}
//		_trenutno = 0;
//	}
//	~FITKolekcija()
//	{
//		for (size_t i = 0; i < max; i++)
//		{
//			delete _elementi1[i]; _elementi1[i] = nullptr;
//			delete _elementi2[i]; _elementi2[i] = nullptr;
//		}
//	}
//	T1** GetT1() { return _elementi1; }
//	T2** GetT2() { return _elementi2; }
//	int GetTrenutno()const { return _trenutno; }
//	void Dodaj(T1 el1, T2 el2) {
//		if (_trenutno == max)
//			throw exception("Nije moguce dodatno dodavanje elemenata");
//		_elementi1[_trenutno] = new T1(el1);
//		_elementi2[_trenutno++] = new T2(el2);
//		
//	}
//
//	void Sortiraj(Sortiranje wayOfSort) {
//		bool sort = true;
//		while (sort)
//		{
//			sort = false;
//			for (size_t i = 0; i < _trenutno-1; i++)
//			{
//				if (*_elementi1[i] > * _elementi1[i + 1] && wayOfSort == RASTUCI) {
//					swap(_elementi1[i], _elementi1[i + 1]);
//					swap(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//				if (*_elementi1[i] < * _elementi1[i + 1] && wayOfSort == OPADAJUCI) {
//					swap(_elementi1[i], _elementi1[i + 1]);
//					swap(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//
//			}
//		}
//	}
//
//	friend ostream& operator<< (ostream& COUT, FITKolekcija& obj)
//	{
//		for (size_t i = 0; i < obj._trenutno; i++)
//			COUT << *obj._elementi1[i] << " " << *obj._elementi2[i] << endl;
//		return COUT;
//	}
//};
//
//
//class Viza
//{
//protected:
//	Drzava _drzava;
//	Datum _vazenjeOD;
//	Datum _vazenjeDO;
//	char* _napomena;
//	// string se odnosi na razlog promjene statusa, a moguæe je samo 10 izmjena statusa
//	FITKolekcija<Status, string, 10> _statusi;
//public:
//	Viza(Drzava drzava, Datum _OD, Datum _DO, const char* napomena = nullptr) :_vazenjeDO(_DO), _vazenjeOD(_OD)
//	{
//		if (napomena != nullptr)
//		{
//			_napomena = new char[strlen(napomena) + 1];
//			strcpy_s(_napomena, strlen(napomena) + 1, napomena);
//		}
//		else
//			_napomena = nullptr;
//		_drzava = drzava;
//	}
//	Viza(const Viza& v) :_drzava(v._drzava), _vazenjeOD(v._vazenjeOD), _vazenjeDO(v._vazenjeDO), _statusi(v._statusi) {
//		if (v._napomena != nullptr) {
//			int size = strlen(v._napomena) + 1;
//			_napomena = new char[size];
//			strcpy_s(_napomena, size, v._napomena);
//		}
//	}
//	~Viza() { delete[] _napomena; _napomena = nullptr; }
//	Datum GetVazenjeOD() { return _vazenjeOD; }
//	Datum GetVazenjeDO() { return _vazenjeDO; }
//	char* GetNapomena() { return _napomena; }
//	FITKolekcija<Status, string, 10> & GetStatuse() { return _statusi; }
//	virtual void Info() = 0;
//	Drzava getDrzava() { return _drzava; }
//
//	void dodajStatus(Status s, string poruka) {
//		_statusi.Dodaj(s, poruka);
//	}
//
//	bool operator==(const Viza& v) {
//		return _drzava==v._drzava;
//	}
//
//};
//
//class PoslovnaViza :public Viza
//{
//	string _kompanija; //naziv kompanije koja potvrðuje da posluje sa aplikantom
//public:
//	PoslovnaViza(Drzava drzava, Datum _OD, Datum _DO, string kompanija, const char* napomena = nullptr) : Viza(drzava, _OD, _DO, napomena)
//	{
//		_kompanija = kompanija;
//	}
//	friend ostream& operator << (ostream& COUT, PoslovnaViza& obj)
//	{
//		COUT << obj._drzava << " " << obj._vazenjeOD << " " << obj._vazenjeDO << " " << obj._kompanija << endl;
//		COUT << ((obj._napomena != nullptr) ? obj._napomena : "") << endl;
//		COUT << "STATUSI -> " << obj._statusi << endl;
//		return COUT;
//	}
//
//	void Info() {
//		cout << *this << endl;
//	}
//
//};
//class TuristickaViza : public Viza
//{
//	string _adresa; //adresa hotele ili drugog smještaja na kojoj æe aplikant boraviti
//public:
//	TuristickaViza(Drzava drzava, Datum _OD, Datum _DO, string adresa, const char* napomena = nullptr) : Viza(drzava, _OD, _DO, napomena)
//	{
//		_adresa = adresa;
//	}
//	friend ostream& operator << (ostream& COUT, TuristickaViza& obj)
//	{
//		COUT << obj._drzava << " " << obj._vazenjeOD << " " << obj._vazenjeDO << " " << obj._adresa << endl;
//		COUT << ((obj._napomena != nullptr) ? obj._napomena : "") << endl;
//		COUT << "STATUSI -> " << obj._statusi << endl;
//		return COUT;
//	}
//	void Info() {
//		cout << *this << endl;
//	}
//};
//
//mutex m;
//class Aplikant
//{
//	char* _imePrezime;
//	Datum* _datumRodjenja;
//	char* _brojPasosa;
//	vector<Viza*> _vize;
//public:
//	Aplikant(const char* imePrezime, Datum datumRodjenja, const char* brPasosa)
//	{
//		int vel = strlen(imePrezime) + 1;
//		_imePrezime = new char[vel];
//		strcpy_s(_imePrezime, vel, imePrezime);
//		vel = strlen(brPasosa) + 1;
//		_brojPasosa = new char[vel];
//		strcpy_s(_brojPasosa, vel, brPasosa);
//		_datumRodjenja = new Datum(datumRodjenja);
//	}
//	~Aplikant()
//	{
//		delete[]_imePrezime; _imePrezime = nullptr;
//		delete[]_brojPasosa; _brojPasosa = nullptr;
//		delete _datumRodjenja; _datumRodjenja = nullptr;
//		for (size_t i = 0; i < _vize.size(); i++)
//		{
//			delete _vize[i]; _vize[i] = nullptr;
//		}
//	}
//	friend ostream& operator << (ostream& COUT, Aplikant& obj)
//	{
//		COUT << obj._imePrezime << " " << *obj._datumRodjenja << " " << *obj._brojPasosa << endl;
//		COUT << "VIZE -> " << endl;
//		for (size_t i = 0; i < obj._vize.size(); i++)
//			obj._vize[i]->Info();
//		return COUT;
//	}
//
//
//	bool DodajVizu(PoslovnaViza *Pviza) {
//		if ((Pviza->GetVazenjeOD().getYear() - _datumRodjenja->getYear()) < 10)
//			return false;
//
//		for (size_t i = 0; i < _vize.size(); i++)
//		{
//			if (_vize[i]->GetVazenjeOD() > Pviza->GetVazenjeDO() || _vize[i]->getDrzava() == Pviza->getDrzava()) {
//				for (size_t j = 0; j < _vize[i]->GetStatuse().GetTrenutno(); j++)
//				{
//					if (*_vize[i]->GetStatuse().GetT1()[j] == Status::IZDATA)
//						return false;
//				}
//			}
//			if (Pviza->getDrzava()==Drzava::SAD && _vize[i]->getDrzava() == Drzava::SAD) {
//				for (size_t j = 0; j < _vize[i]->GetStatuse().GetTrenutno(); j++)
//				{
//					if (*_vize[i]->GetStatuse().GetT1()[j] == Status::PONISTENA)
//						return false;
//				}
//			}
//		}
//		if (dynamic_cast<PoslovnaViza*>(Pviza) != nullptr)
//			_vize.push_back(new PoslovnaViza(*dynamic_cast<PoslovnaViza*>(Pviza)));
//		else if (dynamic_cast<TuristickaViza*>(Pviza) != nullptr)
//			_vize.push_back(new TuristickaViza(*dynamic_cast<TuristickaViza*>(Pviza)));
//			return true;
//	}
//
//	bool DodajStatus(Viza* viza, Status s, string napomena="") {
//		for (size_t i = 0; i < _vize.size(); i++)
//		{
//			bool zahtjev = false;
//			bool izdata = false;
//			if (*_vize[i] == *viza) {
//				for (size_t j = 0; j < _vize[i]->GetStatuse().GetTrenutno(); j++)
//				{
//					if (*_vize[i]->GetStatuse().GetT1()[j] == Status::ZAHTJEV_ZAPRIMLJEN)
//						zahtjev = true;
//					if (*_vize[i]->GetStatuse().GetT1()[j] == Status::IZDATA)
//						izdata = true;
//				}
//			}
//			if (s == Status::ZAHTJEV_ZAPRIMLJEN) {
//				_vize[i]->dodajStatus(s, napomena);
//				return true;
//			}
//			else if (s == Status::ODUSTAO || s == Status::ODBIJENA || s == Status::IZDATA && zahtjev) {
//				_vize[i]->dodajStatus(s, napomena);
//				return true;
//			}
//			else if (s == Status::PONISTENA || s == Status::ISTEKLA && izdata)
//			{
//				_vize[i]->dodajStatus(s, napomena);
//				return true;
//			}
//		}
//		return false;
//	}
//
//	void PrintajVizu(Viza* v) {
//		for (size_t i = 0; i < _vize.size(); i++)
//		{
//			if (*v == *_vize[i]) {
//				thread t([](Viza* v) {
//					m.lock();
//					v->Info();
//					this_thread::sleep_for(chrono::seconds(5));
//					m.unlock();
//					}, _vize[i]);
//				t.join();
//			}
//		}
//	}
//
//	vector<Viza* > GetVize() { return _vize; }
//};
//
//void main()
//{
//	Datum danas(15, 2, 2017);
//	Datum sutra(++danas); // inkrementiranjem se uvecava dan za 1
//	Datum prekosutra;
//	Datum dat15022017(15, 2, 2017), dat18082017(18, 8, 2017), dat11052018(11, 5, 2018), dat11122017(11, 12, 2017);
//	prekosutra = danas;
//	if (prekosutra == danas)
//		cout << "Datumi su jednaki" << endl;
//	cout << danas << endl << sutra << endl << prekosutra << crt;
//	int v6 = 6, v13 = 13, v32 = 32, v63 = 63, v98 = 98, v109 = 109, v196 = 196;
//	FITKolekcija<int, int, 7> brojevi;
//	brojevi.Dodaj(v196, v6);
//	brojevi.Dodaj(v13, v32);
//	brojevi.Dodaj(v98, v196);
//	brojevi.Dodaj(v63, v13);
//	brojevi.Dodaj(v98, v196);
//	brojevi.Dodaj(v196, v6);
//	cout << brojevi << crt;
//	////NA KOJI NAÈIN ÆE SE VRŠITI SORTIRANJE PRVENSTVENO ZAVISI OD VRIJEDNOSTI PARAMETRA, A VRŠI SE NA OSNOVU VRIJEDNOSTI TIPA T1
//	brojevi.Sortiraj(RASTUCI);
//	cout << brojevi << crt;
//	brojevi.Sortiraj(OPADAJUCI);
//	cout << brojevi << crt;
//	try
//	{
//		//U SLUÈAJU PREKORAÈENJA DEFINISANE VELIÈINE KOLEKCIJE, POTREBNO JE BACITI IZUZETAK
//		brojevi.Dodaj(v13, v196);
//	}
//	catch (exception& err)
//	{
//		cout << "Error -> " << err.what() << endl;
//	}
//	Aplikant jasmin("Jasmin Azemovic", Datum(15, 5, 1979), "BS6985645");
//	PoslovnaViza poslovna(SAD, dat15022017, dat18082017, "Microsoft");
//	//// NOVA VIZA SE NE MOŽE DODATI UKOLIKO:
//	//// -	JE APLIKANT MLAÐI OD 10 GODINA
//	//// -	U TOM PERIODU (ODNOSI SE NA PERIOD VIZE OD - DO) NE POSTOJI VAŽEÆA (POJAM VAŽEÆA PODRAZUMIJEVA DA JE POSLJEDNJI STATUS VIZE BIO IZDATA TJ. DA VIZA NIJE 	PONIŠTENA ILI ISTEKLA) VIZA ZA TU DRŽAVU, BEZ OBZIRA NA NJENU VRSTU.	
//	//// -	JE NEKA OD RANIJIH VIZA PONIŠTENA (OVO SE ODNOSI SAMO NA VIZE ZA DRŽAVU: SAD)
//	if (jasmin.DodajVizu(&poslovna))
//		cout << "Podaci o vizi uspješno zaprimljeni" << endl;
//	//// STATUSI SE MOGU DODAVATI SAMO U REDOSLIJEDU U KOJEM SE NALAZE U ENUMERACIJI NPR.
//	//// -	NIJE MOGUÆE ODBITI VIZU AKO PRETHODNO NIJE IMALA STATUS DA JE ZAHTJEV_ZAPRIMLJEN;
//	//// -	NIJE MOGUÆE PONIŠTITI VIZU KOJA PRETHODNO NIJE IZDATA
//	if (jasmin.DodajStatus(&poslovna, ZAHTJEV_ZAPRIMLJEN, "provjeriti navode sa predstavnicima kompanije Microsoft"))
//		cout << "Status vize uspijesno promijenjen" << endl;
//	else
//		cout << "Aplikant " << jasmin << " ne posjeduje evidentiranu trazenu vizu ili status vize nema odgovarajucu vrijednost" << endl;
//	if (jasmin.DodajStatus(&poslovna, PONISTENA, "predstavnicima kompanije Microsoft nemaju informaciju o posjeti navedenog aplikanta"))
//		cout << "Status vize uspijesno promijenjen" << endl;
//	else
//		cout << "Aplikant " << jasmin << " ne posjeduje evidentiranu trazenu vizu ili status vize nema odgovarajucu vrijednost" << endl;
//	TuristickaViza turisticka(ENGLESKA, dat18082017, dat11122017, "Whitehall Pl, London SW1A 2BD, UK");
//	if (jasmin.DodajStatus(&turisticka, ZAHTJEV_ZAPRIMLJEN))
//		cout << "Status vize uspijesno promijenjen" << endl;
//	else
//		cout << "Aplikant " << jasmin << " ne posjeduje evidentiranu trazenu vizu ili status vize nema odgovarajucu vrijednost" << endl;
//	if (jasmin.DodajStatus(&turisticka, IZDATA))
//	{
//		cout << "Status vize uspijesno promijenjen" << endl;
//		//U ZASEBNOJ NITI URADITI PRINTANJE VIZE...KORISTITI METODU SLEEP_FOR
//		jasmin.PrintajVizu(&turisticka);
//	}
//	else
//		cout << "Aplikant " << jasmin << " ne posjeduje evidentiranu trazenu vizu ili status vize nema odgovarajucu vrijednost" << endl;
//	////VRAÆA PODATKE O SVIM VIZAMA KOJE SU IZDATE ZA ODREÐENU DRŽAVU, A KOJE SU IMALE ODREÐENI STATUS
//	//vector<Viza*> jasminVize = jasmin.GetVizeByDrzava(SAD, PONISTENA);
//	////UNUTAR NAPOMENE MIJENJA SADRŽAJ "nemaju informaciju" SA "su upoznti sa" - KORISTITI REGEX
//	//jasmin.ZamijeniRijec("nemaju informaciju", "su upoznti sa");
//}


// kursevi

//#include <iostream>
//#include <vector>
//#include <string>
//#include <regex>
//#include <ctime>
//using namespace std;
//
//bool ProvjeriFormatTelefona(string telefon) {
//	return regex_match(telefon, regex("(\\()(\\d{3})(\\))(\\d{3})(\\-)(\\d{3})"));
//}
//
//class Datum {
//	int* _dan, * _mjesec, * _godina;
//public:
//	Datum(int dan = 1, int mjesec = 1, int godina = 2000) {
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//	}
//	Datum(const Datum& d) {
//		_dan = new int(*d._dan);
//		_mjesec = new int(*d._mjesec);
//		_godina = new int(*d._godina);
//	}
//	~Datum() {
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//	}
//	Datum& operator=(const Datum& d) {
//		*_dan = *d._dan;
//		*_mjesec = *d._mjesec;
//		*_godina = *d._godina;
//		return *this;
//	}
//	bool operator == (const Datum& d) {
//		return *_dan == *d._dan && *_mjesec == *d._mjesec && *_godina == *d._godina;
//	}
//	bool operator > (const Datum& d) {
//		int days = *_dan + *_mjesec * 30 + *_godina * 365;
//		int days_d = *d._dan + *d._mjesec * 30 + *d._godina * 365;
//		return days > days_d;
//	}
//	friend ostream& operator<< (ostream& COUT, const Datum& obj) {
//		COUT << *obj._dan << " " << *obj._mjesec << " " << *obj._godina;
//		return COUT;
//	}
//};
//
//class Izuzetak :public exception {
//	Datum _datum;//KORISTITE DANASNJI DATUM
//	string _funkcija;//FUNKCIJA U KOJOJ JE NASTAO IZUZETAK
//	int _linija;//LINIJA CODE-A U KOJOJ JE NASTAO IZUZETAK
//public:
//	Izuzetak(string fun, int line, const char* poruka) :exception(poruka), _funkcija(fun), _linija(line) {
//		time_t current = time(0);
//		tm localcurrent;
//		localtime_s(&localcurrent, &current);
//		Datum d(localcurrent.tm_mday, localcurrent.tm_mon, localcurrent.tm_year);
//		_datum = d;
//	}
//	friend ostream& operator <<(ostream& output, const Izuzetak& i) {
//		output << "Datum -> " << i._datum << endl;
//		output << "Funkcija -> " << i._funkcija << endl;
//		output << "Linija -> " << i._linija << endl;
//		output << "Poruka -> " << i.what() << endl;
//		return output;
//	}
//};
//
//template<class T1, class T2, int max>
//class Kolekcija {
//	T1 _elementi1[max];
//	T2 _elementi2[max];
//	int* _trenutno;
//public:
//	Kolekcija() :_trenutno(new int(0)) {}
//	~Kolekcija() { delete _trenutno; }
//	Kolekcija(const Kolekcija& k) :_trenutno(new int(*k._trenutno)) {
//		time_t current;
//		time(&current);
//		if (max < k.GetMax()) throw Izuzetak(__FUNCTION__, __LINE__, "Nemoguce kopiranje objekata");
//		for (size_t i = 0; i < *k._trenutno; i++)
//		{
//			_elementi1[i] = k._elementi1[i];
//			_elementi2[i] = k._elementi2[i];
//		}
//	}
//	void AddElement(T1 el1, T2 el2) {
//		time_t current;
//		time(&current);
//		if (*_trenutno == max) throw Izuzetak(__FUNCTION__, __LINE__, "Prekoracili ste kapacitet kolekcija");
//		_elementi1[*_trenutno] = el1;
//		_elementi2[*_trenutno] = el2;
//		(*_trenutno)++;
//	}
//	Kolekcija& operator=(const Kolekcija& k) {
//		*_trenutno = *k._trenutno;
//		for (size_t i = 0; i < *k._trenutno; i++)
//		{
//			_elementi1[i] = k._elementi1[i];
//			_elementi2[i] = k._elementi2[i];
//		}
//		return *this;
//	}
//	int GetMax()const { return max; }
//	T1 GetElement1(int i)const {
//		time_t current = time(0);
//		time(&current);
//		if (i < 0 || i >= *_trenutno) throw Izuzetak(__FUNCTION__, __LINE__, "Nepostojeci element");
//		return _elementi1[i];
//	}
//	T2 GetElement2(int i)const {
//		time_t current = time(0);
//		time(&current);
//		if (i < 0 || i >= *_trenutno) throw Izuzetak(__FUNCTION__, __LINE__, "Nepostojeci element");
//		return _elementi2[i];
//	}
//	T1& operator[](int i) {
//		time_t current = time(0);
//		time(&current);
//		if (i < 0 || i >= *_trenutno) throw Izuzetak(__FUNCTION__, __LINE__, "Nepostojeci element");
//		return _elementi1[i];
//	}
//	int GetTrenutno()const { return *_trenutno; }
//	void Clear() { *_trenutno = 0; }
//	friend ostream& operator<< (ostream& output, const Kolekcija& k) {
//		for (size_t i = 0; i < k.GetTrenutno(); i++)
//			output << k.GetElement1(i) << " " << k.GetElement2(i) << endl;
//		return output;
//	}
//};
//
//enum enumKursevi { HtmlCSSJavaScript, SoftwareEngeneeringFundamentals, MasteringSQL, WindowsSecurity };
//class Kurs {
//	enumKursevi _kurs;
//	Datum _pocetak;
//	Datum _kraj;
//	char* _imePredavaca;
//public:
//	Kurs() :_imePredavaca(nullptr) {}
//	Kurs(enumKursevi kurs, const char* predavac, Datum pocetak, Datum kraj) :_kurs(kurs), _pocetak(pocetak), _kraj(kraj) {
//		int size = strlen(predavac) + 1;
//		_imePredavaca = new char[size];
//		strcpy_s(_imePredavaca, size, predavac);
//	}
//	~Kurs() { delete[] _imePredavaca; }
//	Kurs(const Kurs& k) :_kurs(k._kurs), _pocetak(k._pocetak), _kraj(k._kraj) {
//		int size = strlen(k._imePredavaca) + 1;
//		_imePredavaca = new char[size];
//		strcpy_s(_imePredavaca, size, k._imePredavaca);
//	}
//	bool operator==(const Kurs& k) {
//		return _kurs == k._kurs && _pocetak == k._pocetak && _kraj == k._kraj && strcmp(_imePredavaca, k._imePredavaca) == 0;
//	}
//	Kurs& operator=(const Kurs& k) {
//		if (this != &k) {
//			delete[] _imePredavaca;
//			_kurs = k._kurs;
//			_pocetak = k._pocetak;
//			_kraj = k._kraj;
//			int size = strlen(k._imePredavaca) + 1;
//			_imePredavaca = new char[size];
//			strcpy_s(_imePredavaca, size, k._imePredavaca);
//		}
//		return *this;
//	}
//	const char* GetPredavac() { return _imePredavaca; }
//	Datum GetPocetak() { return _pocetak; }
//	Datum GetKraj() { return _kraj; }
//	enumKursevi GetVrstaKursa() { return _kurs; }
//	friend ostream& operator << (ostream& cout, const Kurs& k) {
//		cout << "Naziv kursa -> " << k._kurs << endl;
//		cout << "Predavac -> " << k._imePredavaca << endl;
//		cout << "Pocetak -> " << k._pocetak << endl;
//		cout << "Kraj -> " << k._kraj << endl;
//		return cout;
//	}
//};
//class Polaznik {
//	static int ID;
//	const int _polaznikID;
//	//SVAKOM NOVOM POLAZNIKU AUTOMATSKI DODIJELITI NOVI ID (AUTOINCREMENT) POCEVSI OD BROJA 1
//	char* _imePrezime;
//	string _kontaktTelefon; //BROJ TELEFONA TREBA BITI U FORMATU (06X)XXX-XXX 
//	Kolekcija<Kurs*, int, 10> _uspjesnoOkoncaniKursevi;
//	//INT PREDSTAVLJA OSTVARENI PROCENAT NA ISPITU, A JEDAN POLAZNIK MOZE POLOZITI NAJVISE 10 KURSEVA
//public:
//	Polaznik(const char* imePrezime, string telefon) :_polaznikID(ID++) {
//		int size = strlen(imePrezime) + 1;
//		_imePrezime = new char[size];
//		strcpy_s(_imePrezime, size, imePrezime);
//		_kontaktTelefon = telefon;
//	}
//	Polaznik(const Polaznik& p) :_polaznikID(p._polaznikID), _kontaktTelefon(p._kontaktTelefon), _uspjesnoOkoncaniKursevi(p._uspjesnoOkoncaniKursevi) {
//		int size = strlen(p._imePrezime) + 1;
//		_imePrezime = new char[size];
//		strcpy_s(_imePrezime, size, p._imePrezime);
//	}
//	void AddKurs(Kurs k, int procenat) {
//		_uspjesnoOkoncaniKursevi.AddElement(new Kurs(k), procenat);
//	}
//	int GetID()const { return _polaznikID; }
//	~Polaznik() {
//		delete[] _imePrezime; _imePrezime = nullptr;
//		for (size_t i = 0; i < _uspjesnoOkoncaniKursevi.GetTrenutno(); i++)
//		{
//			delete _uspjesnoOkoncaniKursevi[i];
//			_uspjesnoOkoncaniKursevi[i] = nullptr;
//		}
//	}
//	bool operator == (const Polaznik& p) {
//		if (_uspjesnoOkoncaniKursevi.GetTrenutno() != p._uspjesnoOkoncaniKursevi.GetTrenutno() || strcmp(_imePrezime, p._imePrezime) != 0) return false;
//		for (size_t i = 0; i < _uspjesnoOkoncaniKursevi.GetTrenutno(); i++)
//			if (_uspjesnoOkoncaniKursevi.GetElement1(i) != p._uspjesnoOkoncaniKursevi.GetElement1(i)) return false;
//		return true;
//	}
//	Polaznik& operator = (const Polaznik& p) {
//		if (this != &p) {
//			_uspjesnoOkoncaniKursevi.Clear();
//			int size = strlen(p._imePrezime) + 1;
//			_imePrezime = new char[size];
//			strcpy_s(_imePrezime, size, p._imePrezime);
//			_kontaktTelefon = p._kontaktTelefon;
//			for (size_t i = 0; i < p._uspjesnoOkoncaniKursevi.GetTrenutno(); i++)
//				_uspjesnoOkoncaniKursevi.AddElement(new Kurs(*p._uspjesnoOkoncaniKursevi.GetElement1(i)), p._uspjesnoOkoncaniKursevi.GetElement2(i));
//		}
//		return *this;
//	}
//	Kolekcija<Kurs*, int, 10> GetUspjenoOkoncaniKursevi() { return _uspjesnoOkoncaniKursevi; }
//	friend ostream& operator << (ostream& cout, const Polaznik& p) {
//		cout << "ID -> " << p._polaznikID << endl << "Ime i prezime -> " << p._imePrezime << endl <<
//			"Telefon -> " << p._kontaktTelefon << "Lista polozenih kurseva -> " << p._uspjesnoOkoncaniKursevi << endl;
//		return cout;
//	}
//};
//int Polaznik::ID = 1;
//class SkillsCentar {
//	string _nazivCentra;
//	vector<Kurs> _kursevi;//KURSEVI KOJE NUDI ODREDJENI CENTAR
//	Kolekcija<Kurs, Polaznik*, 150> _aplikanti;
//public:
//	SkillsCentar(string naziv) { _nazivCentra = naziv; }
//	SkillsCentar(const SkillsCentar& obj) :_kursevi(obj._kursevi), _aplikanti(obj._aplikanti) {
//		_nazivCentra = obj._nazivCentra;
//	}
//	bool ProvjeriKoliziju(Kurs k) {
//		for (size_t i = 0; i < _kursevi.size(); i++)
//		{
//			if (_kursevi[i].GetKraj() > k.GetPocetak()) {
//				return false;
//			}
//		}
//		return true;
//	}
//	void AddKurs(Kurs k) {
//		time_t current;
//		time(&current);
//		for (size_t i = 0; i < _kursevi.size(); i++)
//			if (_kursevi[i] == k) throw Izuzetak(__FUNCTION__, __LINE__, "Nemoguce dodati isti kurs dva puta");
//		_kursevi.push_back(k);
//	}
//	void AddAplikaciju(Kurs k, Polaznik& p) {
//		time_t current;
//		time(&current);
//		bool postoji = false;
//		for (size_t i = 0; i < _kursevi.size(); i++)
//			if (_kursevi[i] == k) {
//				postoji = true;
//				break;
//			}
//		if (!postoji) throw Izuzetak(__FUNCTION__, __LINE__, "Kurs ne postoji.");
//		for (size_t i = 0; i < _aplikanti.GetTrenutno(); i++)
//		{
//			if (_aplikanti.GetElement1(i) == k && *_aplikanti.GetElement2(i) == p) {
//				throw Izuzetak(__FUNCTION__, __LINE__, "Aplikacija za ovaj kurs vec postoji.");
//			}
//		}
//		_aplikanti.AddElement(k, &p);
//	}
//	void DodajUspjesnoOkoncanKurs(int ID, Kurs k, int procenat) {
//		for (size_t i = 0; i < _aplikanti.GetTrenutno(); i++)
//		{
//			if (_aplikanti.GetElement1(i) == k && _aplikanti.GetElement2(i)->GetID() == ID && procenat >= 55) {
//				_aplikanti.GetElement2(i)->AddKurs(k, procenat);
//				return;
//			}
//		}
//	}
//	bool RemoveKurs(Kurs k) {
//		bool remove = true;
//		for (size_t i = 0; i < _aplikanti.GetTrenutno(); i++)
//		{
//			if (_aplikanti.GetElement1(i) == k) remove = false;
//		}
//		if (!remove) return false;
//		for (vector<Kurs>::iterator i = _kursevi.begin(); i != _kursevi.end(); i++)
//		{
//			if (*i == k) {
//				_kursevi.erase(i);
//				return true;
//			}
//		}
//		return false;
//	}
//	vector<Polaznik> GetPolazniciByPredavac(const char* predavac, enumKursevi k) {
//		vector<Polaznik> polaznici;
//		for (size_t i = 0; i < _aplikanti.GetTrenutno(); i++)
//		{
//			for (size_t j = 0; j < _aplikanti.GetElement2(i)->GetUspjenoOkoncaniKursevi().GetTrenutno(); j++)
//			{
//				if (strcmp(_aplikanti.GetElement2(i)->GetUspjenoOkoncaniKursevi().GetElement1(j)->GetPredavac(), predavac) == 0 && _aplikanti.GetElement2(i)->GetUspjenoOkoncaniKursevi().GetElement1(j)->GetVrstaKursa() == k) {
//					polaznici.push_back(*_aplikanti.GetElement2(i));
//				}
//			}
//		}
//		return polaznici;
//	}
//	friend ostream& operator<< (ostream& cout, const SkillsCentar& s) {
//		cout << "Naziv centra -> " << s._nazivCentra << endl << "Lista kurseva: " << endl;
//		for (size_t i = 0; i < s._kursevi.size(); i++)
//			cout << s._kursevi[i] << endl;
//		return cout;
//	}
//};
//const char* crt = "\n---------------------------------------\n";
//void main()
//{
//	/****************************************************************************
//	1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR ĆE BITI OZNACENO KAO "RE"
//	3. SPAŠAVAJTE PROJEKAT KAKO BI SE SPRIJEČILO GUBLJENJE URAĐENOG ZADATKA
//	4. PROGRAMSKI CODE SE TAKOĐER NALAZI U FAJLU CODE.TXT
//	5. NAZIVI FUNKCIJA, TE BROJ I TIP PARAMETARA MORAJU BITI IDENTIČNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U, OSIM U SLUCAJU DA POSTOJI ADEKVATAN RAZLOG ZA NJIHOVU MODIFIKACIJU. OSTALE, POMOĆNE FUNKCIJE MOŽETE IMENOVATI I DODAVATI PO ŽELJI.
//	6. IZUZETAK BACITE U FUNKCIJAMA U KOJIMA JE TO NAZNAČENO.
//	****************************************************************************/
//
//#pragma region TestiranjeDatuma
//	Datum danas(26, 11, 2015);
//	Datum sutra(danas);
//	Datum prekosutra;
//	prekosutra = danas;
//	cout << danas << endl << sutra << endl << prekosutra << crt;
//#pragma endregion
//#pragma region TestiranjeKolekcije
//	Kolekcija<int, int, 10> kolekcija1;
//	try
//	{
//		for (size_t i = 0; i < kolekcija1.GetMax(); i++)
//			kolekcija1.AddElement(i, i + 2);
//		//FUNKCIJA TREBA BACITI IZUZETAK U SLUCAJ DA NEMA VISE PROSTORA ZA DODAVANJE NOVIH ELEMENATA
//		cout << kolekcija1.GetElement1(0) << " " << kolekcija1.GetElement2(0) << endl;
//		cout << kolekcija1.GetElement1(20) << " " << kolekcija1.GetElement2(20) << endl;
//		//FUNKCIJA TREBA DA BACI IZUZETAK UKOLIKO ELEMENT NA ZAHTIJEVANOJ LOKACIJI NE POSTOJI
//	}
//	catch (Izuzetak& err)
//	{
//		cout << "Greska -> " << err << endl;
//	}
//
//	cout << kolekcija1 << endl;
//	Kolekcija<int, int, 10> kolekcija2;
//	kolekcija2 = kolekcija1;
//	cout << kolekcija2 << crt;
//	if (kolekcija1.GetTrenutno() == kolekcija2.GetTrenutno())
//		cout << "ISTI BROJ ELEMENATA" << endl;
//	Kolekcija<int, int, 10> kolekcija3(kolekcija2);
//	cout << kolekcija3 << crt;
//#pragma endregion
//#pragma region TestiranjeKursa
//	Kurs sef(SoftwareEngeneeringFundamentals, "Jasmin Azemovic", Datum(28, 1, 2016), Datum(15, 2, 2016));
//	cout << sef << endl;
//	Kurs msql(MasteringSQL, "Adel Handzic", Datum(28, 2, 2016), Datum(15, 3, 2016));
//	sef = msql;
//	if (sef == msql)//KURSEVI SU ISTI AKO POSJEDUJU IDENTICNE VRIJEDNOSTI SVIH ATRIBUTA
//		cout << "ISTI SU KURSEVI" << endl;
//	Kurs msql2(msql);
//	cout << msql2 << endl;
//#pragma endregion
//#pragma region TestiranjePolaznika
//	string telefon1 = "(061)111-111";
//	string telefon2 = "(061)111222";
//	string telefon3 = "(061)111-333";
//
//	if (!ProvjeriFormatTelefona(telefon1))
//		cout << "Broj " << telefon1 << " nije validan" << endl;
//	if (!ProvjeriFormatTelefona(telefon2))
//		cout << "Broj " << telefon2 << " nije validan" << endl;
//	if (!ProvjeriFormatTelefona(telefon3))
//		cout << "Broj " << telefon3 << " nije validan" << endl;
//
//
//	Polaznik denis("Denis Music", telefon1);
//	Polaznik denis2("Denis2 Music2", telefon3);
//
//#pragma endregion
//
//#pragma region TestiranjeCentra
//	try {
//		SkillsCentar mostar("Skills Center Mostar");
//		if (mostar.ProvjeriKoliziju(sef))
//			//JEDAN KURS NE SMIJE POCETI DOK DRUGI TRAJE TJ. VRIJEME ODRZAVANJA KURSA SE NE SMIJE POKLAPATI
//			mostar.AddKurs(sef);
//		if (mostar.ProvjeriKoliziju(msql))
//			mostar.AddKurs(msql);
//		if (mostar.ProvjeriKoliziju(msql2))
//			mostar.AddKurs(msql2);
//		//ONEMOGUCITI DODAVANJE IDENTICNIH KURSEVA. FUNKCIJA TREBA DA BACI IZUZETAK UKOLIKO SE POKUSA DODATI IDENTICAN KURS
//		mostar.AddAplikaciju(sef, denis);
//		//ONEMOGUCITI APLICIRANJE ZA KURSEVE KOJI NISU REGISTROVANI U CENTRU
//		mostar.AddAplikaciju(msql, denis);
//		mostar.AddAplikaciju(msql, denis);
//		//ONEMOGUCITI APLICIRANJE ZA ISTI KURS. FUNKCIJA BAZA IZUZETAK
//		cout << denis2 << endl;
//		denis2 = denis;
//		if (denis == denis2)
//			//POLAZNICI SU ISTI AKO POSJEDUJU ISTO IME I AKO SU POHADJALI ISTE KURSEVE
//			cout << "ISTI SU" << endl;
//
//		mostar.DodajUspjesnoOkoncanKurs(1, sef, 60);//BROJ 1 OZNACAVA ID POLAZNIKA. FUNKCIJA JE ZADUZENA DA POLAZNIKU DODA INFORMACIJU O USPJESNO POLOZENOM KURSU KOJI JE POSLAN KAO PARAMETAR. PREDUSLOV ZA DODAVANJE JE DA JE POLAZNIK PRETHODNO APLICIRAO ZA TAJ KURS, TE DA JE NA ISPITU OSTVARIO VISE OD 55%
//		mostar.DodajUspjesnoOkoncanKurs(1, msql, 83);
//		vector<Polaznik> listaPolaznika = mostar.GetPolazniciByPredavac("Jasmin Azemovic", SoftwareEngeneeringFundamentals);//VRACA INFORMACIJE O POLAZNICIMA KOJI SU KOD ODREDJENOG PREDAVACA USPJESNO OKONCALI ODREDJENI KURS
//
//		if (mostar.RemoveKurs(sef))//ONEMOGUCITI UKLANJANJE KURSA KOJI SU VEC PRIJAVILI NEKI OD POLAZNIKA
//			cout << "Kurs " << sef << " uspjesno uklonjen iz centra " << mostar << endl;
//		SkillsCentar sarajevo = mostar;
//		cout << sarajevo << endl;
//	}
//	catch (Izuzetak& err) {
//		cout << err << endl;
//	}
//#pragma endregion
//	system("pause");
//}

//transuzijski centar

//#include <iostream>
//#include <vector>
//#include<string>
//#include<regex>
//#include<sstream>
//using namespace std;
//
//const char* crt = "\n-------------------------------------------\n";
//enum OznakaKrvneGrupe { O, A, B, AB };
//const char* OznakaKrvneGrupeString[] = { "O", "A", "B", "AB" };
//
//class Datum {
//	int _dan, _mjesec, _godina;
//public:
//	Datum(int dan, int mjesec, int godina) :
//		_dan(dan), _mjesec(mjesec), _godina(godina) {}
//
//	string ToString(string sep=".")const {
//		stringstream ss;
//		ss << _dan << sep << _mjesec << sep << _godina << endl;
//		return ss.str();
//	}
//
//};
//
//template <class T1, class T2, int max>
//class Kolekcija {
//	T1 _elementi1[max];
//	T2 _elementi2[max];
//	int _trenutnoElemenata;
//	int _keyElement; // kljucni element, a podrazumijevano T1 predstavlja kljucni element i tada je vrijednost 1, a u slucaju da je T2 onda ce vrijednost biti 2
//public:
//	Kolekcija(int keyElement = 1) {
//		_trenutnoElemenata = 0;
//		_keyElement = keyElement;
//	}
//	bool AddElement(T1 ele1, T2 ele2) {
//		if (_trenutnoElemenata == max)
//			return false;
//		_elementi1[_trenutnoElemenata] = ele1;
//		_elementi2[_trenutnoElemenata] = ele2;
//		_trenutnoElemenata++;
//		return true;
//	}
//
//	void SetElement2(int lokacija, T2 ele2) {
//		_elementi2[lokacija] = ele2;
//	}
//	void SetKeyElement(int keyElement) {
//		if (keyElement < 1 || keyElement>2)
//			throw exception("Nedozvoljena vrijednost!");
//		_keyElement = keyElement;
//	}
//	int GetTrenutno() const { return _trenutnoElemenata; }
//	int GetMax() const { return max; }
//
//	T1 GetElement1(int lokacija) const {
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw exception("Nepostojeca lokacija!");
//		return _elementi1[lokacija];
//	}
//	T2 GetElement2(int lokacija) const {
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw exception("Nepostojeca lokacija!");
//		return _elementi2[lokacija];
//	}
//	friend ostream& operator<<(ostream& COUT, const Kolekcija& obj) {
//		for (size_t i = 0; i < obj.GetTrenutno(); i++)
//			COUT << obj.GetElement1(i) << " " << obj.GetElement2(i) << endl;
//		return COUT;
//	}
//
//	void Sort(string tip) {
//		bool sort = true;
//		while (sort)
//		{
//			sort = false;
//			for (size_t i = 0; i < _trenutnoElemenata-1; i++)
//			{
//				if (_elementi1[i] > _elementi1[i + 1] && tip == "ASC" && _keyElement == 1) {
//					swap<T1, T1>(_elementi1[i], _elementi1[i + 1]);
//					swap<T2, T2>(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//				else if (_elementi2[i] > _elementi2[i + 1] && tip == "ASC" && _keyElement == 2) {
//					swap<T1, T1>(_elementi1[i], _elementi1[i + 1]);
//					swap<T2, T2>(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//
//				else if (_elementi1[i] < _elementi1[i + 1] && tip == "DESC" && _keyElement == 1) {
//					swap<T1, T1>(_elementi1[i], _elementi1[i + 1]);
//					swap<T2, T2>(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//				else if (_elementi2[i] < _elementi2[i + 1] && tip == "DESC" && _keyElement == 2) {
//					swap<T1, T1>(_elementi1[i], _elementi1[i + 1]);
//					swap<T2, T2>(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//				
//			}
//		}
//	}
//};
//
//class KrvnaGrupa {
//	/*postoje 4 krvne grupe koje su navedene u enumeracije OznakaKrvneGrupe, pri cemu svaka od navedenih moze imati pozitivan (+) i negativan (-) Rh faktor*/
//	OznakaKrvneGrupe _oznaka;//npr: AB
//	char _rhFaktor; // + ili -
//					/*prethodno pomenuto je izuzetno bitno iz razloga sto postoje jasna pravila vezana za darivanje krvi tj. koji primalac moze primiti krv od kojeg donatora sto je prikazano u tabeli, a naredna dva vector-a su zaduzena da cuvaju informacije o tome, npr. za krvnu grupu A+ vector donatori ce cuvati vrijednosti: A+ i AB+ */
//	vector<KrvnaGrupa> _donatori; //krvne grupe kojima odredjena krvna grupa moze donirati krv.
//	vector<KrvnaGrupa> _primaoci; //krvne grupe od kojih odredjena krvna grupa moze primiti krv.
//public:
//	KrvnaGrupa(OznakaKrvneGrupe oznaka, char rhFaktor) :
//		_oznaka(oznaka), _rhFaktor(rhFaktor) {}
//	void SetDonatori(vector<KrvnaGrupa> donatori) {
//		_donatori = donatori;
//	}
//	void SetPrimaoci(vector<KrvnaGrupa> primaoci) {
//		_primaoci = primaoci;
//	}
//
//
//	string ToString()const {
//		stringstream ss;
//		ss << "Krvna grupa: " << _oznaka << _rhFaktor << endl;
//
//		ss << "Donatori: ";
//		for (vector<KrvnaGrupa>::const_iterator i = _donatori.begin(); i != _donatori.end(); i++) // imamo const iterator kada je funkcija takva
//			ss << i->_oznaka << i->_rhFaktor << endl;
//
//		ss << "Primaoci: ";
//		for (vector<KrvnaGrupa>::const_iterator i = _primaoci.begin(); i != _primaoci.end(); i++) // imamo const iterator kada je funkcija takva
//			ss << i->_oznaka << i->_rhFaktor << endl;
//		ss << crt;
//
//		return ss.str();
//	}
//
//	bool operator==(const KrvnaGrupa& kg) {
//		if(kg._oznaka == _oznaka && kg._rhFaktor==_rhFaktor)return true;
//		return false;
//	}
//
//};
//
////Klasu proglasiti apstraktnom
//class Osoba {
//protected:
//	char* _imePrezime;
//	KrvnaGrupa _krvnaGrupa;
//public:
//	Osoba(const char* imePrezime, KrvnaGrupa krvnaGrupa) : _krvnaGrupa(krvnaGrupa) {
//		int size = strlen(imePrezime) + 1;
//		_imePrezime = new char[size];
//		strcpy_s(_imePrezime, size, imePrezime);
//	}
//
//	Osoba(const Osoba& os):_krvnaGrupa(os._krvnaGrupa) {
//		int size = strlen(os._imePrezime) + 1;
//		_imePrezime = new char[size];
//		strcpy_s(_imePrezime, size, os._imePrezime);
//	}
//	virtual ~Osoba() {
//		delete[] _imePrezime;
//		_imePrezime = nullptr;
//	}
//
//	KrvnaGrupa GetKrvnaGrupa() { return _krvnaGrupa; }
//
//	bool operator==(const Osoba& os) {
//		return strcmp(os._imePrezime, _imePrezime) == 0;
//	}
//
//	friend ostream& operator <<(ostream& o, const Osoba& osoba) {
//		o << osoba._imePrezime << osoba._krvnaGrupa.ToString() << endl;
//		return o;
//	}
//};
//
//class Donator : public Osoba {
//	//u slucaju da broj telefona nije u validnom formatu potrebno ga je postaviti na podrazumijevanu vrijednost: 000-000-000
//	string _telefon; //regex: 000/000-000 ili 000-000-000
//	Datum _datumPosljednjegDoniranja;
//	bool _podsjetiMe;
//	bool _kontaktirajMe;
//
//public:
//	Donator(const char* imePrezime, KrvnaGrupa krvnaGrupa, string telefon, Datum dpd, bool remind = true, bool contact = true)
//		: Osoba(imePrezime, krvnaGrupa), _datumPosljednjegDoniranja(dpd) {
//		//if (ValidanFormat(telefon))
//		//	_telefon = telefon;
//		//else
//		//	_telefon = "000-000-000";
//	}
//
//	void SetDatumPosljednjegDoniranja(Datum dat)
//	{
//		_datumPosljednjegDoniranja = dat;
//	}
//
//	friend ostream& operator<<(ostream& o, const Donator& d) {
//		o << "Telefon -> " << d._telefon << endl;
//		o << "Datum posljednjeg doniranja" << d._datumPosljednjegDoniranja.ToString() << endl;
//		return o;
//	}
//
//
//};
//
//class Zahtjev {
//	string _ustanova;
//	Datum _datumZahtjeva;
//	KrvnaGrupa _krvnaGrupa;
//	double _kolicina;
//public:
//	Zahtjev(string ustanova, Datum datum, KrvnaGrupa krvnaGrupa, double kolicina) :
//		_ustanova(ustanova), _datumZahtjeva(datum), _krvnaGrupa(krvnaGrupa), _kolicina(kolicina) { }
//
//	
//
//	friend ostream& operator<<(ostream& COUT, const Zahtjev& obj) {
//		COUT << "Ustanova: " << obj._ustanova << endl;
//		COUT << "Datum: " << obj._datumZahtjeva.ToString() << endl;
//		COUT << "Krvna grupa: " << obj._krvnaGrupa.ToString() << endl;
//		COUT << "Kolicina: " << obj._kolicina << endl;
//		return COUT;
//	}
//};
//
//class TransfuzijskiCentar {
//	//stanje zaliha za svaku pojedinu krvnu grupu
//	Kolekcija<KrvnaGrupa*, double, 8> _zalihe;
//	//evidentira svaku donaciju krvi
//	Kolekcija<Osoba*, double, 100> _donacije;
//	vector<Zahtjev> _zahtjevi;
//
//public:
//	/*prilikom svake donacije je potrebno povecati zalihe za tu krvnu grupu
//	ukoliko krvna grupa vec postoji na zalihi onda se uvecava samo njena kolicina
//	takodjer, donatoru se postavlja nova vrijednost datuma posljednje donacije
//	*/
//	void AddDonaciju(Datum datumDon, Osoba *o, float kol) {
//		bool postojiGrupa = false;
//		for (size_t i = 0; i < _zalihe.GetTrenutno(); i++)
//		{
//			if (*_zalihe.GetElement1(i) == o->GetKrvnaGrupa()) {
//				_zalihe.SetElement2(i, _zalihe.GetElement2(i) + kol);
//				postojiGrupa = true;
//			}
//		}
//		if (!postojiGrupa)
//			_zalihe.AddElement(new KrvnaGrupa(o->GetKrvnaGrupa()), kol);
//
//		Donator* don = dynamic_cast<Donator*>(o);
//		for (size_t i = 0; i < _donacije.GetTrenutno(); i++)
//		{
//			if (*_donacije.GetElement1(i) == *o) {
//				dynamic_cast<Donator*>(_donacije.GetElement1(i))->SetDatumPosljednjegDoniranja(datumDon);
//				_donacije.SetElement2(i, _donacije.GetElement2(i) + kol);
//			}
//		}
//_donacije.AddElement(new Donator(*don), kol);
//	}
//
//	~TransfuzijskiCentar() {
//		for (size_t i = 0; i < _zalihe.GetTrenutno(); i++)
//			delete _zalihe.GetElement1(i);
//		for (size_t i = 0; i < _donacije.GetTrenutno(); i++)
//			delete _donacije.GetElement1(i);
//	}
//};
//
//void main() {
//
//	/**************************************************************************
//	1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR CE BITI OZNACENO KAO "RE"
//	3. SPASAVAJTE PROJEKAT KAKO BI SE SPRIJECILO GUBLJENJE URADJENOG ZADATKA
//	4. PROGRAMSKI CODE SE TAKODJER NALAZI U FAJLU code.TXT
//	5. NAZIVI FUNKCIJA MORAJU BITI IDENTIÈNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U.OSTALE, POMOÆNE FUNKCIJE MOŽETE IMENOVATI PO ŽELJI. TAKOÐER, MOŽETE DODAVATI KOLIKO ŽELITE TESTNIH PODATAKA
//	****************************************************************************/
//	Datum dat_12_01_2018(12, 1, 2018), dat_01_02_2018(1, 2, 2018);
//	cout << dat_01_02_2018.ToString() << endl; //podrazumijevani separator je tacka ".", pa ispisuje 1.2.2018
//	cout << dat_12_01_2018.ToString("/") << endl; //separator je proslijedjen, pa ispisuje 12/1/2018
//
//	Kolekcija<int, int, 10> kolekcija1;
//	for (size_t i = 0; i < kolekcija1.GetMax(); i++)
//		if (!kolekcija1.AddElement(i, 170000 + i))
//			cout << "Elementi " << i << " i " << 170000 + i << " nisu dodati u kolekciju" << endl;
//
//	cout << kolekcija1.GetElement1(0) << " " << kolekcija1.GetElement2(0) << endl;
//
//	kolekcija1.Sort("ASC"); //kljucne rijeci za sortiranje su ASC i DESC, a sortiranje se vrsi prema kljucnom elementu
//	cout << kolekcija1 << endl << endl << endl;
//	kolekcija1.Sort("DESC");
//	cout << kolekcija1 << endl;
//
//	kolekcija1.SetKeyElement(2);//postavlja kljucni element na T2
//
//	kolekcija1.Sort("DESC"); //sada se sortiranje vrsi po elementu T2
//	cout << kolekcija1 << endl;
//
//	KrvnaGrupa
//		O_poz(O, '+'), O_neg(O, '-'),
//		A_poz(A, '+'), A_neg(A, '-'),
//		B_poz(B, '+'), B_neg(B, '-'),
//		AB_poz(AB, '+'), AB_neg(AB, '-');
//
//	vector<KrvnaGrupa> donori_O_poz{ O_poz, A_poz, B_poz, AB_poz };
//	O_poz.SetDonatori(donori_O_poz);
//	//ili krace napisano
//	O_poz.SetPrimaoci(vector<KrvnaGrupa>{O_poz, O_neg});
//	A_poz.SetDonatori(vector<KrvnaGrupa>{A_poz, AB_poz});
//	A_poz.SetPrimaoci(vector<KrvnaGrupa>{O_poz, A_poz, O_neg, A_neg});
//
//	B_poz.SetDonatori(vector<KrvnaGrupa>{B_poz, AB_poz});
//	B_poz.SetPrimaoci(vector<KrvnaGrupa>{O_poz, B_poz, O_neg, B_neg});
//	/*
//	Ispis podataka o krvnoj grupi treba biti u formatu:
//	-------------------------------------------
//	Krvna grupa -> 0+
//	-------------------------------------------
//	Donori  ->  0+, A+, B+, AB+
//	Primaoci ->	0+, 0-
//	-------------------------------------------
//	*/
//	cout << O_poz.ToString() << endl;
//
//	Osoba* jasmin = new Donator("Jasmin Azemovic", B_poz, "061-111-222", Datum(12, 2, 2017), true, true);
//	Osoba* adel = new Donator("Adel Handzic", A_neg, "061-222-333", Datum(9, 1, 2017), true, true);
//	Osoba* goran = new Donator("Goran Skondric", B_neg, "061-333-444", Datum(9, 3, 2017), true, true);
//
//
//	TransfuzijskiCentar tcMostar;
//	///*
//	//prilikom svake donacije je potrebno povecati zalihe za tu krvnu grupu
//	//ukoliko krvna grupa vec postoji na zalihi onda se uvecava samo njena kolicina
//	//takodjer, donatoru se postavlja nova vrijednost datuma posljednje donacije
//	//*/
//	///datum donacije, donator, kolicina
//	tcMostar.AddDonaciju(Datum(20, 5, 2017), jasmin, 2.5);
//	tcMostar.AddDonaciju(Datum(20, 5, 2017), adel, 3);
//	tcMostar.AddDonaciju(Datum(6, 5, 2017), goran, 1.2);
//
//
//	tcMostar.AddDonaciju(Datum(10, 9, 2017), jasmin, 2);
//	tcMostar.AddDonaciju(Datum(18, 10, 2017), adel, 1.8);
//	tcMostar.AddDonaciju(Datum(15, 9, 2017), goran, 3.8);
//
//	Zahtjev zahtjev_0_poz("Tranfuziologija KCUS", Datum(18, 2, 2018), O_poz, 15),
//		zahtjev_0_neg("Tranfuziologija Bakir Nakas", Datum(20, 2, 2018), O_neg, 8);
//
//	///*ukoliko transfuzijski centar posjeduje zahtijevane kolicine na stanju, odmah ce ih ustupiti prema zahtjevu,
//	//a u slucaju da ne posjeduje onda ce (koristeci multithreading) kontaktirati (poslati SMS poruku sa odgovarajucim sadrzajem)
//	//sve donore koji zadovoljavaju sljedece uslove:
//	//- mogu donirati krv zahtijevanoj krvnoj grupi
//	//- oznacili su da zele biti kontaktirani
//	//- nisu davali krv u posljednja 3 mjeseca
//	//*/
//	//tcMostar.DodajZahtjev(zahtjev_0_poz);
//	//tcMostar.DodajZahtjev(zahtjev_0_neg);
//
//	////printa zahvalnice (zahvaljujemo se ime i prezime donatoru na ukupno doniranih X doza krvi) za TOP 2 donatora krvi
//	//tcMostar.GetZahvalniceZahvalnice(2);
//
//	delete adel;
//	delete jasmin;
//	delete goran;
//}


//komunikacija

//#include<iostream>
//#include<string>
//#include<vector>
//#include<regex>
//#include<sstream>
//using namespace std;
//
//const char* crt = "\n-------------------------------------------\n";
//enum stringFormat { DDMMGG, DDMMGGGG, DDMMGGSSMM, DDMMGGGGSSMM };
//enum prikazPoruka { SVE_PORUKE, SAKRIJ_POBRISANE, PRIKAZI_SAMO_POBRISANE };
//vector<string> nedozvoljeneRijeci;
//
////DDMMGG - 29.8.17
////DDMMGGGG - 29.8.2017
////DDMMGGGGSSMM - 29.8.2017 10:15
//
//
//template<class T1, class T2>
//class Kolekcija {
//	T1* _elementi1;
//	T2* _elementi2;
//	int* _trenutno;
//public:
//	Kolekcija()
//	{
//		_elementi1 = nullptr;
//		_elementi2 = nullptr;
//		_trenutno = new int(0);
//	}
//
//	Kolekcija& operator=(Kolekcija<T1, T2>& orig)
//	{
//		if (this != &orig)
//		{
//			delete[]_elementi1;
//			delete[]_elementi2;
//
//			_elementi1 = new T1[*orig._trenutno];
//			_elementi2 = new T2[*orig._trenutno];
//			*_trenutno = *orig._trenutno;
//
//			for (int i = 0; i < *_trenutno; i++)
//			{
//				_elementi1[i] = orig._elementi1[i];
//				_elementi2[i] = orig._elementi2[i];
//			}
//		}
//		return *this;
//	}
//
//	bool AddElement(T1 elem1, T2 elem2)
//	{
//		T1* temp1 = new T1[*_trenutno + 1];
//		T2* temp2 = new T2[*_trenutno + 1];
//
//		for (int i = 0; i < *_trenutno; i++) {
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//
//		delete[] _elementi1;
//		delete[] _elementi2;
//
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//
//		_elementi1[*_trenutno] = elem1;
//		_elementi2[*_trenutno] = elem2;
//		(*_trenutno)++;
//		return true;
//	}
//	~Kolekcija()
//	{
//		delete[]_elementi1; _elementi1 = nullptr;
//		delete[]_elementi2; _elementi2 = nullptr;
//		delete _trenutno; _trenutno = nullptr;
//	}
//
//	T1* getElementi1Pok() { return _elementi1; }
//	T2* getElementi2Pok() { return _elementi2; }
//	T1& getElement1(int lokacija) { return _elementi1[lokacija]; }
//	T2& getElement2(int lokacija) { return _elementi2[lokacija]; }
//	int getTrenutno() { return *_trenutno; }
//
//	friend ostream& operator<<(ostream& COUT, Kolekcija<T1, T2>& obj)
//	{
//		for (size_t i = 0; i < *obj._trenutno; i++)
//		{
//			COUT << obj.getElement1(i) << " " << obj.getElement2(i) << endl;
//		}
//		return COUT;
//	}
//};
//class DatumVrijeme {
//	int* _dan, * _mjesec, * _godina, * _sati, * _minuti;
//public:
//	DatumVrijeme(int dan = 1, int mjesec = 1, int godina = 2000, int sati = 0, int minuti = 0) {
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//		_sati = new int(sati);
//		_minuti = new int(minuti);
//	}
//
//	DatumVrijeme(const DatumVrijeme& dat) {
//		_dan = new int(*dat._dan);
//		_mjesec = new int(*dat._mjesec);
//		_godina = new int(*dat._godina);
//		_sati = new int(*dat._sati);
//		_minuti = new int(*dat._minuti);
//	}
//
//	~DatumVrijeme() {
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//		delete _sati; _sati = nullptr;
//		delete _minuti; _minuti = nullptr;
//	}
//
//	void operator=(const DatumVrijeme& dat) {
//		if (this != &dat) {
//			*_dan = *dat._dan;
//			*_mjesec= *dat._mjesec;
//			*_godina = *dat._godina;
//			*_sati = *dat._sati;
//			*_minuti = *dat._minuti;
//		}
//	}
//
//	string ToString(stringFormat format)const {
//		stringstream ss;
//		if (format == stringFormat::DDMMGGGG)
//			ss << *_dan << "." << *_mjesec << "." << *_godina << endl;
//		else if (format == stringFormat::DDMMGGGGSSMM)
//			ss << *_dan << "." << *_mjesec << "." << *_godina << " " << *_sati << ":" << *_minuti << endl;
//		else if (format == stringFormat::DDMMGGSSMM)
//			ss << *_dan << "." << *_mjesec << "." << *_godina%100 << " " << *_sati << ":" << *_minuti << endl;
//		else if (format == stringFormat::DDMMGG)
//			ss << *_dan << "." << *_mjesec << "." << *_godina%100<< endl;
//
//		return ss.str();
//	}
//
//	friend ostream& operator<< (ostream& COUT, DatumVrijeme& obj) {
//		COUT << *obj._dan << "." << *obj._mjesec << "." << *obj._godina << " " << *obj._sati << ":" << *obj._minuti << endl;
//		return COUT;
//	}
//};
//class Poruka {
//	string _posiljalac;
//	string _primalac;
//	string _sadrzaj;
//	DatumVrijeme _vrijeme;
//public:
//	Poruka() {
//
//		_posiljalac = "NOT_SET";
//		_primalac = "NOT_SET";
//		_sadrzaj = "NOT_SET";
//	}
//	Poruka(string posiljalac, string primalac, string sadrzaj, DatumVrijeme vrijeme) :_vrijeme(vrijeme)
//	{
//		_posiljalac = posiljalac;
//		_primalac = primalac;
//		_sadrzaj = sadrzaj;
//	}
//	friend ostream& operator<< (ostream& COUT, Poruka& obj) {
//		COUT << "(" << obj._vrijeme << ") " << obj._posiljalac << " -> ";
//		COUT << obj._sadrzaj;
//		return COUT;
//	}
//	string getPrimalac() { return _primalac; }
//	string getPosiljalac() { return _posiljalac; }
//	string getSadrzaj() { return _sadrzaj; }
//};
//class Komunikacija {
//	string _naslov;
//	int _ocjena; //ocjena komunikacije 1 - 5 se automatski izracunava
//	Kolekcija<Poruka, bool> _poruke;//bool se odnosi na podatak da li je poruka pobrisana tj. nece biti vidljiva u prikazu ukoliko se drugacije ne navede
//public:
//	
//	Komunikacija() {
//		_naslov = "NOT_SET";
//		_ocjena = 0;
//	}
//	Komunikacija(string naslov) {
//		_naslov = naslov;
//		_ocjena = -1;
//	}
//	friend ostream& operator<< (ostream& COUT, Komunikacija& obj) {
//		COUT << "(" << obj._ocjena << ") " << obj._naslov << " -> ";
//		for (int i = 0; i < obj._poruke.getTrenutno(); i++)
//		{
//			COUT << obj.getPoruke()[i] << endl;
//		}
//		return COUT;
//	}
//	Kolekcija<Poruka, bool>* getPoruke() { return &_poruke; }
//	int getOcjena() { return _ocjena; }
//	string getNaslov() { return _naslov; }
//};
//
//class Korisnik {
//	string _korisnickoIme;
//	char* _imePrezime;
//	//char * - se odnosi na naziv predmeta ili tema gdje će se čuvati kompletna komunikacija sa nastavnim osobljem ili korisnikom na određenom predmetu/temi
//	Kolekcija<char*, Komunikacija> _komunikacija;
//public:
//	Korisnik(const char* korisnickoIme, const char* imePrezime)
//	{
//		int vel = strlen(imePrezime) + 1;
//		_imePrezime = new char[vel];
//		strcpy_s(_imePrezime, vel, imePrezime);
//		_korisnickoIme = korisnickoIme;
//	}
//	Korisnik(Korisnik& original) :_komunikacija(original._komunikacija)
//	{
//		int vel = strlen(original._imePrezime) + 1;
//		_imePrezime = new char[vel];
//		strcpy_s(_imePrezime, vel, original._imePrezime);
//		_korisnickoIme = original._korisnickoIme;
//	}
//
//	~Korisnik()
//	{
//		delete[] _imePrezime; _imePrezime = nullptr;
//	}
//	friend ostream& operator<< (ostream& COUT, Korisnik& obj)
//	{
//		COUT << obj._imePrezime << endl << obj._komunikacija << endl;
//		return COUT;
//	}
//	Kolekcija<char*, Komunikacija>* GetKomunikacija() { return &_komunikacija; }
//	string getKorisnickoIme() { return _korisnickoIme; }
//
//	///*ispisuje sve poruke koje je korisnik razmijenio pod naslovom definisanim parametrom. ispis komunikacije
//	//treba biti organizovan po datumu na nacin da se prvo prikaze datum, a nakon toga sve poruke koje su razmijenjene tog datuma.
//	//Na mjestima pobrisanih poruka prikazati tekst "PORUKA IZBRISANA"
//	//*/
//	void PrikaziKomunikacijuPoNaslovu(string naslov, prikazPoruka prikaz) {
//		if (prikaz == prikazPoruka::SVE_PORUKE) {
//			for (size_t i = 0; i < _komunikacija.getTrenutno(); i++)
//			{
//				if (strcmp(_komunikacija.getElement1(i), naslov.c_str()) == 0) {
//					for (size_t j = 0; j < _komunikacija.getElement2(i).getPoruke()->getTrenutno(); j++)
//					{
//						if (!_komunikacija.getElement2(i).getPoruke()->getElement2(j))
//							cout << _komunikacija.getElement2(i).getPoruke()->getElement1(j) << endl;
//						else
//							cout << "Poruka izbrisana!" << endl;
//					}
//				}
//
//			}
//		}
//		else if (prikaz == prikazPoruka::SAKRIJ_POBRISANE) {
//			for (size_t i = 0; i < _komunikacija.getTrenutno(); i++)
//			{
//				if (strcmp(_komunikacija.getElement1(i), naslov.c_str()) == 0) {
//					for (size_t j = 0; j < _komunikacija.getElement2(i).getPoruke()->getTrenutno(); j++)
//					{
//						if (!_komunikacija.getElement2(i).getPoruke()->getElement2(j))
//							cout << _komunikacija.getElement2(i).getPoruke()->getElement1(j) << endl;
//					}
//
//				}
//			}
//		}
//		else if (prikaz == prikazPoruka::PRIKAZI_SAMO_POBRISANE) {
//			for (size_t i = 0; i < _komunikacija.getTrenutno(); i++)
//			{
//				if (strcmp(_komunikacija.getElement1(i), naslov.c_str()) == 0) {
//					for (size_t j = 0; j < _komunikacija.getElement2(i).getPoruke()->getTrenutno(); j++)
//					{
//						if (!_komunikacija.getElement2(i).getPoruke()->getElement2(j))
//							cout << _komunikacija.getElement2(i).getPoruke()->getElement1(j) << endl;
//					}
//
//				}
//			}
//		}
//	}
//
//	/*funkcija prikazuje sve poruke sa korisnikom cije korisnicko ime je definisano parametrom,
//	te vraca ukupan broj (razmijenjenih poruka sa tim korisnikom)*/
//	int PrikaziKomunikacijuSaKorisnikom(string korisnickoIme) {
//		int brojac = 0;
//		for (size_t i = 0; i < _komunikacija.getTrenutno(); i++)
//		{
//			for (size_t j = 0; j < _komunikacija.getElement2(i).getPoruke()->getTrenutno(); j++)
//			{
//				if (_komunikacija.getElement2(i).getPoruke()->getElement1(j).getPosiljalac() == korisnickoIme
//					|| _komunikacija.getElement2(i).getPoruke()->getElement1(j).getPrimalac() == korisnickoIme)
//					cout << _komunikacija.getElement2(i).getPoruke()->getElement1(j) << endl;
//				brojac++;
//			}
//
//		}
//		return brojac;
//	}
//
//
//};
//
//void PosaljiPoruku(Korisnik** korisnici, int vel, string naslov,
//	string imePrimaoca, string imePosiljaoca,
//	string sadrzaj, DatumVrijeme dat) {
//
//	string rule = "(";
//	bool primalac = false;
//	bool posiljalac = false;
//	for (size_t i = 0; i < nedozvoljeneRijeci.size(); i++)
//	{
//		rule += nedozvoljeneRijeci[i];
//		if (i != nedozvoljeneRijeci.size() - 1)
//			rule += "|";
//	}
//
//	rule += ")";
//	if (regex_search(sadrzaj, regex(rule))) throw exception("U sadrzaju postoji zabranjena rijec!");
//	for (size_t i = 0; i < vel; i++)
//	{
//		if (korisnici[i]->getKorisnickoIme() == imePosiljaoca)
//			posiljalac = true;
//		if (korisnici[i]->getKorisnickoIme() == imePrimaoca)
//			primalac = true;
//	}
//	if (!posiljalac || !primalac) throw exception("Nepostojeci korisnik");
//
//	for (size_t i = 0; i < vel; i++)
//	{
//		if (korisnici[i]->getKorisnickoIme() == imePosiljaoca || korisnici[i]->getKorisnickoIme() == imePrimaoca) {
//			bool komunikacija = false;
//			for (size_t j = 0; j < korisnici[i]->GetKomunikacija()->getTrenutno(); j++)
//			{
//				if (strcmp(naslov.c_str(), korisnici[i]->GetKomunikacija()->getElement1(j)) == 0) {
//					korisnici[i]->GetKomunikacija()->getElement2(j).getPoruke()->AddElement(Poruka(imePosiljaoca, imePrimaoca, sadrzaj, dat),false);
//					komunikacija = true;
//				}
//
//			}
//			if (!komunikacija) {
//				int vel = strlen(naslov.c_str()) + 1;
//				char* naziv = new char[vel];
//				strcpy_s(naziv, vel, naslov.c_str());
//				korisnici[i]->GetKomunikacija()->AddElement(naziv, Komunikacija(naslov));
//				korisnici[i]->GetKomunikacija()->getElement2(korisnici[i]->GetKomunikacija()->getTrenutno()-1)
//					.getPoruke()->AddElement(Poruka(imePosiljaoca, imePrimaoca, sadrzaj, dat), false);
//			}
//		}
//
//	}
//}
//
//
//
//void main()
//{
//
//	/****************************************************************************
//	1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR ĆE BITI OZNACENO KAO "RE"
//	3. SPAŠAVAJTE PROJEKAT KAKO BI SE SPRIJEČILO GUBLJENJE URAĐENOG ZADATKA
//	4. PROGRAMSKI CODE SE TAKOĐER NALAZI U FAJLU CODE.TXT
//	5. NAZIVI FUNKCIJA, TE BROJ I TIP PARAMETARA MORAJU BITI IDENTIČNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U, OSIM U SLUČAJU DA POSTOJI ADEKVATAN RAZLOG ZA NJIHOVU MODIFIKACIJU. OSTALE, POMOĆNE FUNKCIJE MOŽETE IMENOVATI I DODAVATI PO ŽELJI.
//	6. IZUZETAK BACITE U FUNKCIJAMA U KOJIMA JE TO NAZNAČENO.
//	****************************************************************************/
//
//
//	/*riječi koje su zabranjene u komunikaciji*/
//	nedozvoljeneRijeci.push_back("ubiti");
//	nedozvoljeneRijeci.push_back("mrzim");
//	nedozvoljeneRijeci.push_back("rat");
//
//	DatumVrijeme temp,
//		datum19062017_1015(19, 6, 2017, 10, 15),
//		datum19062017_1020(19, 6, 2017, 10, 20),
//		datum19062017_1021(19, 6, 2017, 10, 21),
//		datum19062017_1030(19, 6, 2017, 10, 30);
//
//	cout << datum19062017_1015.ToString(DDMMGGGG) << endl;//vraca string: 19.6.2017
//	cout << datum19062017_1015.ToString(DDMMGGGGSSMM) << endl;//vraca string: 19.6.2017 10:15
//
//
//	const int max = 3;
//	Korisnik* korisnici[max];
//	korisnici[0] = new Korisnik("jasmin", "Jasmin Azemovic");
//	korisnici[1] = new Korisnik("adel", "Adel Handzic");
//	korisnici[2] = new Korisnik("denis", "Denis Music");
//
//	/*
//	sve poruke se cuvaju u komunikaciji posiljaoca i primaoca tako da u svakom momentu oba ucesnika u komunikaciji posjeduju kompletnu historiju poruka. poruke se grupisu na osnovu naslova, pa ce poruke pod naslovom "Sastanak" izmedju dva korisnika sadrzavati sve poruke koje su razmijenjene na tu temu
//	u slucaju da posiljalac ili primalac ne postoje funkcija treba baciti izuzetak sa odgovarajucom porukom. takodjer, koristeci regex sve poruke koje sadrze neku od zabranjenih rijeci trebaju biti oznacene kao
//	*/
//	PosaljiPoruku(korisnici, max, "Sastanak",
//		korisnici[0]->getKorisnickoIme(), korisnici[1]->getKorisnickoIme(),
//		"Danas imamo sastanak u 10h!", datum19062017_1015);
//
//	PosaljiPoruku(korisnici, max, "Sastanak",
//		korisnici[1]->getKorisnickoIme(), korisnici[0]->getKorisnickoIme(),
//		"Naravno, vidimo se u sali za sastanke!", datum19062017_1020);
//
//	PosaljiPoruku(korisnici, max, "Sastanak",
//		korisnici[0]->getKorisnickoIme(), korisnici[1]->getKorisnickoIme(),
//		"Sa sobom ponesi radni materijal!", datum19062017_1021);
//
//	///*ispisuje sve poruke koje je korisnik razmijenio pod naslovom definisanim parametrom. ispis komunikacije
//	//treba biti organizovan po datumu na nacin da se prvo prikaze datum, a nakon toga sve poruke koje su razmijenjene tog datuma.
//	//Na mjestima pobrisanih poruka prikazati tekst "PORUKA IZBRISANA"
//	//*/
//	korisnici[0]->PrikaziKomunikacijuPoNaslovu("Sastanak", SVE_PORUKE);
//
//	/*funkcija prikazuje sve poruke sa korisnikom cije korisnicko ime je definisano parametrom, 
//	te vraca ukupan broj (razmijenjenih poruka sa tim korisnikom)*/
//	int ukupnoPoruka = korisnici[0]->PrikaziKomunikacijuSaKorisnikom("adel");
//
//	///*formira ocjenu na nivou komunikacije na nacin da izracunava prosjecno vrijeme odgovora drugog ucesnika izrazeno u minutama i to prema sljedecoj skali
//	//prosjek > 20 minuta = ocjena 1
//	//prosjek > 15 minuta = ocjena 2
//	//prosjek > 10 minuta = ocjena 3
//	//prosjek > 5 minuta = ocjena 4
//	//prosjek <=5 minuta = ocjena 5
//	//*/
//	//korisnici[0]->OcijeniKomunikaciju("Sastanak");
//
//	for (size_t i = 0; i < max; i++)
//	{
//		delete korisnici[i];
//		korisnici[i] = nullptr;
//	}
//
//	system("PAUSE");
//}


//Aktivnosti


//#include<iostream>
//#include<vector>
//#include<string>
//#include<regex>
//#include<tuple>
//using namespace std;
//
//
//const char* nedozvoljena_operacija = "Nedozvoljena operacija";
//const char* not_set = "NOT_SET";
//
//enum Sortiranje { ASC, DESC };
//enum Predmet { MATEMATIKA, FIZIKA, HEMIJA, GEOGRAFIJA, NOT_SET };
//enum Razred { I = 1, II, III, IV };
//
//char* AlocirajNizKaraktera(const char* sadrzaj) {
//	if (sadrzaj == nullptr)
//		return nullptr;
//	int vel = strlen(sadrzaj) + 1;
//	char* temp = new char[vel];
//	strcpy_s(temp, vel, sadrzaj);
//	return temp;
//}
//template <class T1, class T2, int max>
//class Kolekcija {
//	T1* _elementi1[max] = { nullptr };
//	T2* _elementi2[max] = { nullptr };
//	int _trenutnoElemenata;
//	bool _dozvoliDupliranje;
//	Sortiranje _sortiranje;
//public:
//	Kolekcija(Sortiranje sortiranje = ASC, bool dozvoliDupliranje = true) {
//		_trenutnoElemenata = 0;
//		_sortiranje = sortiranje;
//		_dozvoliDupliranje = dozvoliDupliranje;
//	}
//	Kolekcija(const Kolekcija& kol) {
//		_trenutnoElemenata = kol._trenutnoElemenata;
//		_dozvoliDupliranje = kol._dozvoliDupliranje;
//		_sortiranje = kol._sortiranje;
//		for (size_t i = 0; i < kol._trenutnoElemenata; i++)
//		{
//			_elementi1[i] = new T1(*kol._elementi1[i]);
//			_elementi2[i] = new T2(*kol._elementi2[i]);
//
//		}
//	}
//
//	~Kolekcija() {
//		for (size_t i = 0; i < _trenutnoElemenata; i++) {
//			delete _elementi1[i]; _elementi1[i] = nullptr;
//			delete _elementi2[i]; _elementi2[i] = nullptr;
//		}
//	}
//	int GetTrenutno() const { return _trenutnoElemenata; }
//	int GetMax() const { return max; }
//
//	T1& GetElement1(int lokacija) const {
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw exception(nedozvoljena_operacija);
//		return *_elementi1[lokacija];
//	}
//	T2& GetElement2(int lokacija) const {
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw exception(nedozvoljena_operacija);
//		return *_elementi2[lokacija];
//	}
//	void SetElement2(int lokacija, T2 ele2) {
//		_elementi2[lokacija] = ele2;
//	}
//
//	bool AddElement(T1 el1, T2 el2) {
//		if (_trenutnoElemenata == max)
//			throw exception("Dosegli ste maksimum!\n");
//			_elementi1[_trenutnoElemenata] = new T1(el1);
//			_elementi2[_trenutnoElemenata] = new T2(el2);
//			_trenutnoElemenata++;
//
//			sortiraj();
//			return true;
//	}
//
//	void sortiraj() {
//		bool sort = true;
//		while (sort)
//		{
//			sort = false;
//			for (size_t i = 0; i < _trenutnoElemenata-1; i++)
//			{
//				if (*_elementi1[i] > *_elementi1[i + 1] && _sortiranje == ASC) {
//					swap(_elementi1[i], _elementi1[i + 1]);
//					swap(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//				else if (*_elementi1[i] < *_elementi1[i + 1] && _sortiranje == DESC)
//				{
//					swap(_elementi1[i], _elementi1[i + 1]);
//					swap(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//			}
//		}
//	}
//	friend ostream& operator<<(ostream& COUT, const Kolekcija& obj) {
//		for (size_t i = 0; i < obj.GetTrenutno(); i++)
//			COUT << obj.GetElement1(i) << " " << obj.GetElement2(i) << endl;
//		return COUT;
//	}
//};
//
//class Aktivnost {
//	shared_ptr<Razred> _razred;
//	string _opis;
//	int _ocjena;//1-5
//public:
//	Aktivnost(Razred razred = I, int ocjena = 0, string opis = not_set) {
//		_ocjena = ocjena;
//		_opis = opis;
//		_razred = make_shared<Razred>(razred);
//	}
//	int  GetOcjenu() const { return _ocjena; }
//	string GetOpis() const { return _opis; }
//	Razred GetRazred() const { return *_razred; }
//
//	friend ostream& operator<<(ostream& COUT, const Aktivnost& obj) {
//		COUT << *obj._razred << " " << obj._ocjena << " " << obj._opis << endl;
//		return COUT;
//	}
//};
//
//class Polaznik {
//protected:
//	char* _imePrezime;
//	string _brojTelefona;
//
//	bool formatTelefona(string Telefon) {
//		//koristeci regex, osigurati sljedeci format za broj telefona: +387(6X)XXX-XXX ili +387 6X XXX-XXX
//		if (regex_match(Telefon, regex("([+])(\\d{3})([(])(\\d{2})([)])(\\d{3})([-])(\\d{3}) || ([+])(\\d{3})(\\d{2})(\\d{3})([-])(\\d{3})")))
//			return true;
//		else Telefon = "not_set"; return false;
//	}
//
//public:
//	Polaznik(string imePrezime, string brojTelefona) : _imePrezime(AlocirajNizKaraktera(imePrezime.c_str())) {
//		if(formatTelefona(brojTelefona))
//		_brojTelefona = brojTelefona;
//	}
//	~Polaznik() { delete[] _imePrezime; }
//	char* GetImePrezime() { return _imePrezime; }
//	string GetTelefon() { return _imePrezime; }
//	virtual void PredstaviSe() = 0;
//};
//
//class Ucenik:public Polaznik {
//	Kolekcija<Predmet, Aktivnost, 16> * _aktivnosti;
//public:
//	Ucenik(string imePrezime="NOT_SET",string brojTelefona="NOT_SET") :Polaznik(imePrezime, brojTelefona) {
//		_aktivnosti = new Kolekcija<Predmet,Aktivnost,16>();
//	}
//	Ucenik(const Ucenik& uc):Polaznik(uc._imePrezime,uc._brojTelefona) {
//		_aktivnosti = new Kolekcija<Predmet, Aktivnost, 16>(*uc._aktivnosti);
//	}
//	~Ucenik() { delete _aktivnosti; _aktivnosti = nullptr; }
//	Kolekcija<Predmet, Aktivnost, 16> & GetAktivnosti() { return *_aktivnosti; };
//	virtual void PredstaviSe() {
//		cout << "Ime i prezime: " << _imePrezime << endl;
//		cout << "Broj telefona: " << _brojTelefona << endl;
//		cout << "Aktivnosti ->";
//		if (_aktivnosti->GetTrenutno() == 0)
//			cout << "Trenutno nema aktivnosti" << endl;
//		else {
//			for (size_t i = 0; i < _aktivnosti->GetTrenutno(); i++)
//				cout << _aktivnosti->GetElement2(i)<< endl; 
//				// aktivnosti[i] - pristupam lokaciji aktivnosti koje nema TREBAM ELEMENTU SVAKOM PRISTUPT
//		}
//	}
//
//	Ucenik& operator()(Predmet predm, const Aktivnost& akt) {
//			_aktivnosti->AddElement(predm, akt);
//			return *this;
//	}
//	
//	friend ostream& operator<<(ostream& COUT, Ucenik& n)
//	{
//		n.PredstaviSe();
//		return COUT;
//	}
//
//	double GetProsjecnu() {
//		double prosjecna = 0;
//		for (size_t i = 0; i < _aktivnosti->GetTrenutno(); i++)
//			prosjecna += _aktivnosti->GetElement2(i).GetOcjenu();
//
//		return prosjecna /= _aktivnosti->GetTrenutno();
//	}
//
//};
//
//class Skola {
//	char* _naziv;
//	vector<Ucenik> _ucenici;
//public:
//	Skola(const char* naziv = nullptr) {
//		_naziv = AlocirajNizKaraktera(naziv);
//	}
//	~Skola() {
//		delete[] _naziv; _naziv = nullptr;
//	}
//	char* GetNaziv()const { return _naziv; }
//	vector<Ucenik>& GetUcenici() { return _ucenici; };
//
//	friend ostream& operator<<(ostream& COUT, Skola& obj) {
//		COUT << "Skola: " << obj._naziv << endl;
//		COUT << "Ucenici: " << endl;
//		for (size_t i = 0; i < obj._ucenici.size(); i++)
//			COUT << obj._ucenici[i] << endl;
//		return COUT;
//	}
//
//	void operator()(string imePrezime, string telefon) {
//		for (vector<Ucenik>::iterator i = _ucenici.begin(); i != _ucenici.end(); i++)
//		{
//			if (i->GetImePrezime() == imePrezime || i->GetTelefon() == telefon)
//				throw exception("Ucenik vec postoji!");
//		}
//		_ucenici.push_back(Ucenik(imePrezime,telefon));
//	}
//
//	/*na nivou svakog razreda se mogu evidentirati maksimalno 4 aktivnosti, 
//	a takodjer, na nivou razreda se ne smiju ponavljati aktivnosti iz istog predmeta*/
//
//	Ucenik* GetUcenik(string imePrezime) {
//		for (size_t i = 0; i < _ucenici.size(); i++)
//		{
//			if (_ucenici[i].GetImePrezime() == imePrezime)
//				return &_ucenici[i];
//		}
//		return nullptr;
//	}
//
//	bool DodajAktivnost(string imePrezime, Predmet predm, const Aktivnost& akt) {
//
//		Ucenik& uc = *GetUcenik(imePrezime);	
//		double prosjek = 0;
//
//		if (GetUcenik(imePrezime) == nullptr) return false;
//
//		int brojacRazreda = 0;
//		for (size_t i = 0; i < uc.GetAktivnosti().GetTrenutno(); i++)
//		{
//			if (akt.GetRazred() == uc.GetAktivnosti().GetElement2(i).GetRazred()) {
//				brojacRazreda++;
//				prosjek += uc.GetAktivnosti().GetElement2(i).GetOcjenu();
//				if (predm == uc.GetAktivnosti().GetElement1(i))
//					return false;
//			}
//		}
//		if (brojacRazreda >= 4) return false;
//
//		prosjek /= brojacRazreda;
//		uc(predm, akt);
//		return true;
//	}
//
//
//	pair<Polaznik*, float> GetNajboljegUcenika() {
//		vector<double>ocjene;
//		int naj = 0;
//		for (size_t i = 0; i < _ucenici.size(); i++)
//		
//			ocjene.push_back(_ucenici[i].GetProsjecnu());
//
//		for (size_t i = 1; i < ocjene.size(); i++)
//		{
//			if (ocjene[i] > ocjene[naj])
//				naj = i;
//		}
//		return make_pair(&_ucenici[naj], (float)ocjene[naj]);
//	}
//};
//
//int main() {
//
//
//	Kolekcija<int, int, 10> kolekcija1(DESC, false);
//	try {
//		kolekcija1.AddElement(1, 2);
//		//dupliranje elemenata nije dozvoljeno
//		kolekcija1.AddElement(1, 2);
//	}
//	catch (exception& ex) {
//		cout << ex.what();
//	}
//
//	///*nakon svakog dodavanja, elemente sortirati prema T1 i vrijednosti atributa _sortiranje*/
//	for (size_t i = 1; i < kolekcija1.GetMax() - 1; i++)
//		kolekcija1.AddElement(rand(), rand());
//
//	cout << kolekcija1 << endl;
//
//	try {
//		//prekoracen maksimalan broj elemenata
//		kolekcija1.AddElement(rand(), rand());
//	}
//	catch (exception& ex) {
//		cout << ex.what();
//	}
//	cout << kolekcija1 << endl;
//
//	Kolekcija<int, int, 10> kolekcija2(kolekcija1);
//	cout << kolekcija2 << endl;
//
//	Skola gimnazijaMostar("GIMNAZIJA MOSTAR");
//	////dodaje novog ucenika u skolu
//	gimnazijaMostar("Jasmin Azemovic", "+387(61)111-222");
//	gimnazijaMostar("Adel Handzic", "+387(61)333-444");
//
//	///*
//	//koristeci regex, osigurati sljedeci format za broj telefona: +387(6X)XXX-XXX ili +387 6X XXX-XXX
//	//onemoguciti pojavljivanje samo jedne zagrade, a ukoliko format nije adekvatna koristiti vrijednost not_set
//	//*/
//	gimnazijaMostar("Telefon NotValidFormat", "387 61)333-444");
//
//	try
//	{
//		/*onemoguciti dodavanje ucenika sa istim imenom i prezimenom ili brojem telefona*/
//		gimnazijaMostar("Adel Handzic", "+387(61)333-444");
//	}
//	catch (exception& ex)
//	{
//		cout << ex.what() << endl;
//	}
//
//	if (gimnazijaMostar.DodajAktivnost("Jasmin Azemovic", MATEMATIKA, Aktivnost(I, 4, "Priprema za takmicenje iz Matematije koje se odrzava u Konjicu 07.02.2019")))
//		cout << "Aktivnost uspjesno dodana" << endl;
//	/*na nivou svakog razreda se mogu evidentirati maksimalno 4 aktivnosti, a takodjer, na nivou razreda se ne smiju ponavljati aktivnosti iz istog predmeta*/
//	if (!gimnazijaMostar.DodajAktivnost("Jasmin Azemovic", MATEMATIKA, Aktivnost(I, 4, "Aktivnosti iz matematike")))
//		cout << "Aktivnost nije uspjesno dodana" << endl;
//	if (gimnazijaMostar.DodajAktivnost("Jasmin Azemovic", HEMIJA, Aktivnost(I, 5, "Priprema otopina za vjezbe iz predmeta Hemija")))
//		cout << "Aktivnost uspjesno dodana" << endl;
//	if (gimnazijaMostar.DodajAktivnost("Jasmin Azemovic", FIZIKA, Aktivnost(I, 4, "Analiza stepena apsorpcije materijala ")))
//		cout << "Aktivnost uspjesno dodana" << endl;
//	///*u slucaju da je ucenik uspjesno (ocjenom vecom od 1) realizovao aktivnosti na nivou odredjenog razreda, te posjeduje validan broj telefona,
//	//u okviru zasebnog thread-a se salje SMS sa sadrzajem "Uspjesno ste okoncali aktivnosti u okviru X razreda sa prosjecnom ocjenom X.X"*/
//	if (gimnazijaMostar.DodajAktivnost("Jasmin Azemovic", GEOGRAFIJA, Aktivnost(I, 4, "Izrada 5 reljefa Mostara")))
//		cout << "Aktivnost uspjesno dodana" << endl;
//	if (gimnazijaMostar.DodajAktivnost("Adel Handzic", MATEMATIKA, Aktivnost(I, 5, "Izrada skripte na temu integralni racun")))
//		cout << "Aktivnost uspjesno dodana" << endl;
//
//	////ispisuje sve ucenike i njihove aktivnosti
//	cout << gimnazijaMostar << endl;
//
//
//	pair<Polaznik*, float> par = gimnazijaMostar.GetNajboljegUcenika();
//	cout << "Najbolji ucenik je " << par.first->GetImePrezime() << " sa prosjekom " << par.second << endl;
//
//	///*U fajl (npr. Gimnazija.txt) upisati podatke (podatke upisati kao obicni tekst) o skoli i svim ucenicima.
//	//Nakon upisa, potrebno je ispisati sadrzaj fajla. Parametar tipa bool oznacava da li ce ranije dodani sadrzaj fajla prethodno biti pobrisan*/
//
//	//if (gimnazijaMostar.SpasiUFajl("Gimnazija.txt"))
//	//	cout << "Podaci o ucenicima uspjesno pohranjeni u fajl" << endl;
//	//if (gimnazijaMostar.SpasiUFajl("Gimnazija.txt", true))
//	//	cout << "Podaci o ucenicima uspjesno pohranjeni u fajl" << endl;
//
//	cin.get();
//	system("pause>0");
//	return 0;
//}

// ============================================ //


//#include<iostream>
//#include<vector>
//#include<string>
//#include<regex>
//using namespace std;
//const char* crt = "\n-----------------------------------\n";
//
//class Datum {
//	int* _dan, * _mjesec, * _godina;
//public:
//	Datum(int dan = 1, int mjesec = 1, int godina = 2000) {
//		_dan = new int(dan);
//		_mjesec = new int(mjesec);
//		_godina = new int(godina);
//	}
//	Datum(const Datum& dat) {
//		_dan = new int(*dat._dan);
//		_mjesec = new int(*dat._mjesec);
//		_godina = new int(*dat._godina);
//	}
//	~Datum() {
//		delete _dan; _dan = nullptr;
//		delete _mjesec; _mjesec = nullptr;
//		delete _godina; _godina = nullptr;
//	}
//	friend ostream& operator<<(ostream& COUT, const Datum& obj) {
//		COUT << *obj._dan << " " << *obj._mjesec << " " << *obj._godina;
//		return COUT;
//	}
//
//	void operator=(const Datum& dat) {
//		if (this != &dat) {
//			*_dan = *dat._dan;
//			*_mjesec = *dat._mjesec;
//			*_godina = *dat._godina;
//		}
//
//	}
//
//};
//
//class Izuzetak : public exception {
//	string _funkcija;
//public:
//	Izuzetak(const char* poruka, string funkcija):exception(poruka),_funkcija(funkcija) {}
//	friend ostream& operator<<(ostream& cout, const Izuzetak& iz) {
//		cout << "Poruka: " << iz.what() << endl;
//		cout << "Funkcija: " << iz._funkcija << endl;
//		return cout;
//}
//
//};
//
//template <class T1, class T2>
//class Kolekcija {
//	T1* _elementi1;
//	T2* _elementi2;
//	int _trenutnoElemenata;
//	bool _omoguciDupliranjeElemenata;
//public:
//	Kolekcija(bool omoguciDupliranjeElemenata = false) {
//		_trenutnoElemenata = 0;
//		_omoguciDupliranjeElemenata = omoguciDupliranjeElemenata;
//		_elementi1 = nullptr;
//		_elementi2 = nullptr;
//	}
//
//	Kolekcija(const Kolekcija& kol) {
//		_trenutnoElemenata = kol._trenutnoElemenata;
//		_omoguciDupliranjeElemenata = kol._omoguciDupliranjeElemenata;
//		_elementi1 = new T1[kol._trenutnoElemenata];
//		_elementi2 = new T2[kol._trenutnoElemenata];
//		for (size_t i = 0; i < kol._trenutnoElemenata; i++)
//		{
//			_elementi1[i] = kol._elementi1[i];
//			_elementi2[i] = kol._elementi2[i];
//		}
//	}
//	~Kolekcija() {
//		delete[]_elementi2; _elementi2 = nullptr;
//		delete[]_elementi1; _elementi1 = nullptr;
//		_trenutnoElemenata = 0;
//	}
//
//	int GetTrenutno() const { return _trenutnoElemenata; }
//	
//	void SetElement2(int lokacija,T2 el2)const {
//		if (lokacija<0 || lokacija>_trenutnoElemenata)
//			throw Izuzetak("Lokacija nije valjana!",__FUNCTION__);
//		_elementi2[lokacija]=el2;
//	}
//
//	T1& GetElement1(int lokacija) const
//	{
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw Izuzetak("Nepostojeca lokacija", __FUNCTION__);
//		return _elementi1[lokacija];
//	}
//
//	T2& GetElement2(int lokacija) const
//	{
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw Izuzetak("Nepostojeca lokacija", __FUNCTION__);
//		return _elementi2[lokacija];
//	}
//
//	friend ostream& operator<<(ostream& COUT, const Kolekcija& obj) {
//		for (size_t i = 0; i < obj.GetTrenutno(); i++)
//			COUT << obj._elementi1[i] << " " << obj._elementi2[i] << endl;
//		return COUT;
//	}
//
//	bool AddElement(T1 el1, T2 el2) {
//
//		for (size_t i = 0; i < _trenutnoElemenata; i++)
//		{
//			if (_elementi1[i] == el1 && _elementi2[i] == el2)
//				return false;
//		}
//
//		T1* temp1 = new T1[_trenutnoElemenata + 1];
//		T2* temp2 = new T2[_trenutnoElemenata + 1];
//		for (size_t i = 0; i < _trenutnoElemenata; i++)
//		{
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//		delete[]_elementi1;
//		delete[]_elementi2;
//		temp1[_trenutnoElemenata] = el1;
//		temp2[_trenutnoElemenata] = el2;
//		_trenutnoElemenata++;
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//		return true;
//	}
//
//	bool RemoveElement(T1 el1) {
//		int indeks = -1;
//		for (size_t i = 0; i < _trenutnoElemenata; i++)
//		{
//			if (_elementi1[i] == el1)
//				indeks = i;
//		}
//		if (indeks == -1) return false;
//
//		for (size_t i = indeks; i < _trenutnoElemenata-1; i++)
//		{
//			_elementi1[i] = _elementi1[i + 1];
//			_elementi2[i] = _elementi2[i + 1];
//		}
//		_trenutnoElemenata--;
//		return true;
//	}
//
//	void operator=(const Kolekcija& kol) {
//		if (this != &kol) {
//			delete[]_elementi1;
//			delete[]_elementi2;
//			_trenutnoElemenata = kol._trenutnoElemenata;
//			_omoguciDupliranjeElemenata = kol._omoguciDupliranjeElemenata;
//			_elementi1 = new T1[kol._trenutnoElemenata];
//			_elementi2 = new T2[kol._trenutnoElemenata];
//			for (size_t i = 0; i < kol._trenutnoElemenata; i++)
//			{
//				_elementi1[i] = kol._elementi1[i];
//				_elementi2[i] = kol._elementi2[i];
//			}
//		}
//	}
//};
//
//class Dogadjaj
//{
//	Datum _datumOdrzavanja;
//	Kolekcija<string, bool>* _obaveze; //cuva informaciju o obavezama koje je potrebno ispuniti prije samog dogadjaja, string se odnosi na opis, a bool na izvrsenje te obaveze (da li je zavrsena ili ne)
//
//	char* _naziv;
//	int _notificirajPrije; //oznacava broj dana prije samog dogadjaja kada ce krenuti notifikacija/podsjetnik
//	bool _rekurzivnaNotifikacija; //ako je vrijednost true onda se korisnik notificira svaki dan do _datumaOdrzavanja dogadjaja, a pocevsi prije dogadjaja za _brojDanaZaNotifikaciju
//
//	
//public:
//	Dogadjaj(Datum datumOdrzavanja, const char* naziv, int brojDana = 1,
//		bool rekurzivnaNotifikacija = false) : _datumOdrzavanja(datumOdrzavanja)
//	{
//		_naziv = new char[strlen(naziv) + 1];
//		strcpy_s(_naziv, strlen(naziv) + 1, naziv);
//
//		_notificirajPrije = brojDana;
//		_rekurzivnaNotifikacija = rekurzivnaNotifikacija;
//		_obaveze = nullptr;
//	}
//
//	Dogadjaj(const Dogadjaj& obj) : _datumOdrzavanja(obj._datumOdrzavanja)
//	{
//		_naziv = new char[strlen(obj._naziv) + 1];
//		strcpy_s(_naziv, strlen(obj._naziv) + 1, obj._naziv);
//
//		_notificirajPrije = obj._notificirajPrije;
//		_rekurzivnaNotifikacija = obj._rekurzivnaNotifikacija;
//		_obaveze = new Kolekcija<string,bool>;
//	}
//	~Dogadjaj()
//	{
//		delete[] _naziv;
//		_naziv = nullptr;
//		delete _obaveze;
//		_obaveze = nullptr;
//	}
//	char* GetNaziv() { return _naziv; }
//	Kolekcija<string, bool>* GetObaveze() { return _obaveze; }
//
//	bool validnost(string naziv) {
//		return regex_search(naziv, regex("neko|nesto|trazim|nekoliko"));
//	}
//	bool AddObavezu(string naziv) {
//		if (_obaveze == nullptr)
//			_obaveze = new Kolekcija<string, bool>;
//		if (validnost(naziv)) 
//			throw Izuzetak("Nije moguce dodati!",__FUNCTION__);
//		return _obaveze->AddElement(naziv, false); // vrati element kao true ili false a ne da vracas true kako god se ova funkcija izvrsila
//	}
//
//
//	bool operator==(const Dogadjaj& dog) {
//		return strcmp(_naziv, dog._naziv) == 0;
//	}
//
//};
//
//class Student
//{
//	int _indeks;
//	string _imePrezime;
//	vector<Dogadjaj> _dogadjaji;
//public:
//
//	Student(int indeks, string imePrezime) : _indeks(indeks), _imePrezime(imePrezime) {}
//
//	int GetIndeks() const { return _indeks; }
//
//	vector<Dogadjaj>& GetDogadjaji() { return _dogadjaji; }
//
//	friend ostream& operator<<(ostream& COUT, const Student& obj)
//	{
//		COUT << obj._imePrezime << " (" << obj._indeks << ")" << endl;
//		return COUT;
//	}
//
//
//	bool AddDogadjaj(Dogadjaj dog) {
//		for (vector<Dogadjaj>::iterator i = _dogadjaji.begin(); i != _dogadjaji.end(); i++)
//		{
//			if (*i == dog)
//				return false;
//		}
//		_dogadjaji.push_back(dog);
//		return true;
//	}
//
//};
//
//class DLWMSReminder
//{
//	vector<Student> _reminiderList;
//public:
//	void AddStudent(Student stud) {
//		for (vector<Student>::iterator i = _reminiderList.begin(); i < _reminiderList.end(); i++)
//		{
//			if (i->GetIndeks() == stud.GetIndeks())
//				throw Izuzetak("Nije moguce dodati studenta", __FUNCTION__);
//		}
//		_reminiderList.push_back(stud);
//	}
//
//	//da bi bila oznacena kao zavrsena, obaveza mora postojati i mora biti oznacena kao nezavrsena (false)
//	bool OznaciObavezuKaoZavrsenu(int indeks, string naslov, string sadrzaj) {
//		for (vector<Student>::iterator i = _reminiderList.begin(); i < _reminiderList.end(); i++)
//		{
//			if (i->GetIndeks() == indeks) {
//
//				for (vector<Dogadjaj>::iterator j = i->GetDogadjaji().begin(); j != i->GetDogadjaji().end(); j++)
//				{
//					if (j->GetNaziv() == naslov && j->GetObaveze() != nullptr) {
//						for (size_t k = 0; k < j->GetObaveze()->GetTrenutno(); k++)
//						{
//							if (j->GetObaveze()->GetElement1(k) == sadrzaj)
//								j->GetObaveze()->SetElement2(k, true);
//							return true;
//						}
//					}
//				}
//			}
//		}
//			return false;
//	}
//};
//
//void main() {
//
//	/**************************************************************************
//	1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR CE BITI OZNACENO KAO "RE"
//	3. SPASAVAJTE PROJEKAT KAKO BI SE SPRIJECILO GUBLJENJE URADJENOG ZADATKA
//	4. PROGRAMSKI CODE SE TAKODJER NALAZI U FAJLU CODE_ParcijalniII.TXT
//	5. NAZIVI FUNKCIJA MORAJU BITI IDENTIČNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U.OSTALE, POMOĆNE FUNKCIJE MOŽETE IMENOVATI PO ŽELJI.
//	****************************************************************************/
//
//#pragma region Datum
//
//	Datum danas(28, 1, 2018), sutra(29, 1, 2018);
//	Datum datumIspitaPRIII(30, 1, 2018), datumIspitBPII(31, 1, 2018);
//	Datum prekosutra(danas);
//	prekosutra = danas;
//	cout << danas << endl
//		<< sutra << endl
//		<< prekosutra << crt;
//
//#pragma endregion
//
//#pragma region Kolekcija
//
//	/*
//	AddElement :: omogucava dodavanje novog elementa u kolekciju. 
//	Ukoliko je moguce, osigurati automatsko prosiranje kolekcije prilikom dodavanja svakog novog elementa, 
//	te onemoguciti ponavljanje elemenata
//	RemoveElement :: na osnovu parametra tipa T1 uklanja elemente iz kolekcije i ukoliko je moguce smanjuje velicinu niza/kolekcije. 
//	Prilikom uklanjanja elemenata ocuvati redoslijed njihovog dodavanja
//	*/
//	const int brElemenata = 10;
//	Kolekcija<int, float> kolekcija1;
//	for (size_t i = 0; i < brElemenata; i++)
//		if (!kolekcija1.AddElement(i, i + (0.6 * i)))
//			cout << "Elementi " << i << " i " << i + (0.6 * i) << " nisu dodati u kolekciju" << endl;
//
//	cout << kolekcija1.GetElement1(0) << " " << kolekcija1.GetElement2(0) << endl;
//	cout << kolekcija1 << endl;
//
//	kolekcija1.RemoveElement(1);
//
//	Kolekcija<int, float> kolekcija2;
//	kolekcija2 = kolekcija1;
//	cout << kolekcija2 << crt;
//
//	if (kolekcija1.GetTrenutno() == kolekcija2.GetTrenutno())
//		cout << "ISTI BROJ ELEMENATA" << endl;
//
//	Kolekcija<int, float> kolekcija3(kolekcija2);
//	cout << kolekcija3 << crt;
//
//#pragma endregion
//
//#pragma region Dogadjaj
//
//	Dogadjaj ispitPRIII(datumIspitaPRIII, "Ispit iz PRIII", 5, true),
//		ispitBPII(datumIspitBPII, "Ispit iz BPII", 7, true);
//	/*po vlasitom izboru definisati listu zabranjenih rijeci koje ce onemoguciti dodavanje odredjene obaveze. 
//	Prilikom provjere koristiti regex*/
//	if (ispitPRIII.AddObavezu("Preraditi pdf materijale"))cout << "Obaveza dodana!" << endl;
//	////onemoguciti dupliranje obaveza
//	if (!ispitPRIII.AddObavezu("Preraditi pdf materijale"))cout << "Obaveza nije dodana!" << endl;
//	if (ispitPRIII.AddObavezu("Pregledati video materijale"))cout << "Obaveza dodana!" << endl;
//	if (ispitPRIII.AddObavezu("Preraditi ispitne zadatke"))cout << "Obaveza dodana!" << endl;
//	if (ispitPRIII.AddObavezu("Samostalno vjezbati"))cout << "Obaveza dodana!" << endl;
//
//	if (ispitBPII.AddObavezu("Preraditi knjigu SQL za 24 h"))cout << "Obaveza dodana!" << endl;
//	if (ispitBPII.AddObavezu("Pregledati video materijale"))cout << "Obaveza dodana!" << endl;
//	if (ispitBPII.AddObavezu("Napraviti bazu za konkretnu aplikaciju"))cout << "Obaveza dodana!" << endl;
//
//	Student jasmin(150051, "Jasmin Azemovic"), adel(160061, "Adel Handzic");
//
//	if (jasmin.AddDogadjaj(ispitPRIII) && jasmin.AddDogadjaj(ispitBPII))
//		cout << "Dogadjaj uspjesno dodan!" << endl;
//
//	if (adel.AddDogadjaj(ispitPRIII) && adel.AddDogadjaj(ispitBPII))
//		cout << "Dogadjaj uspjesno dodan!" << endl;
//	//onemoguciti dupliranje dogadjaja
//	if (!adel.AddDogadjaj(ispitPRIII))
//		cout << "Dogadjaj nije uspjesno dodan!" << endl;
//
//	DLWMSReminder reminder;
//
//	try
//	{
//		reminder.AddStudent(jasmin);
//		reminder.AddStudent(adel);
//		//u slucaju dupliranja studenata funkcija baca izuzetak tipa Izuzetak
//		reminder.AddStudent(jasmin);
//	}
//	catch (exception& err)
//	{
//		Izuzetak iz = dynamic_cast<Izuzetak&>(err);
//		cout << iz << endl;
//
//		//ispisati sve informacije o nastalom izuzetku
//	}
//
//	//da bi bila oznacena kao zavrsena, obaveza mora postojati i mora biti oznacena kao nezavrsena (false)
//	if (reminder.OznaciObavezuKaoZavrsenu(150051, "Ispit iz PRIII", "Pregledati video materijale"))
//		cout << "Obaveza oznacena kao zavrsena" << endl;
//
//	///*metodi PosaljiNotifikacije se salje trenutni datum na osnovu cega ona pretrazuje sve studente koje treba podsjetiti/notoficirati o dogadjajima koji se priblizavaju.
//	//Koristeci multithread-ing, svim studentima se salju notifikacije sa sljedecim sadrzajem:
//	//-------------------------------------------------------------------------
//	//Postovani Jasmin Azemovic,
//	//Dogadjaj Ispit iz PRIII je zakazan za 3 dana, a do sada ste obavili 56% obaveza vezanih za ovaj dogadjaj. Neispunjene obaveze su:
//	//1.Preraditi ispitne zadatke
//	//2.Samostalno vjezbati
//	//Predlazemo Vam da ispunite i ostale planirane obaveze.
//	//FIT Reminder
//	//-------------------------------------------------------------------------
//	//Dakle, notifikacije ce biti poslane svim studentima koji su dodali dogadjaj za 30.01.2018. godine i oznacili da zele da budu podsjecani ponovo/rekurzivno najmanje 2 dana prije samog dogadjaja (podaci se odnose na konkretan dogadjaj: Ispit iz PRIII)
//	//*/
//	//int poslato = 0;
//	////funkcija vraca broj poslatih podsjetnika/notifikacija
//	//poslato = reminder.PosaljiNotifikacije(danas);
//	//cout << "Za " << danas << " poslato ukupno " << poslato << " podsjetnika!" << endl;
//	//poslato = reminder.PosaljiNotifikacije(sutra);
//	//cout << "Za " << sutra << " poslato ukupno " << poslato << " podsjetnika!" << endl;
//
//#pragma endregion
//
//	system("pause");
//}


//#include<iostream>
//#include<vector>
//#include<string>
//
//using namespace std;
//
//const char* nedozvoljena_operacija = "Nedozvoljena operacija";
//const char* not_set = "NOT_SET";
//const int min_polgavlja = 3;
//const int min_karaktera_po_poglavlju = 30;
//
//char* AlocirajNizKaraktera(const char* sadrzaj) {
//	if (sadrzaj == nullptr)
//		return nullptr;
//	int vel = strlen(sadrzaj) + 1;
//	char* temp = new char[vel];
//	strcpy_s(temp, vel, sadrzaj);
//	return temp;
//}
//
//template<class T1, class T2>
//class Kolekcija {
//	T1* _elementi1;
//	T2* _elementi2;
//	int _trenutno;
//public:
//	Kolekcija() :_trenutno(0), _elementi1(nullptr), _elementi2(nullptr) { }
//
//	void AddElement(const T1& elem1, const T2& elem2) {
//
//		for (int i = 0; i < _trenutno; i++)
//			if (_elementi1[i] == elem1 || _elementi2[i] == elem2)
//				throw exception(nedozvoljena_operacija);
//
//		T1* temp1 = new T1[_trenutno + 1];
//		T2* temp2 = new T2[_trenutno + 1];
//		for (int i = 0; i < _trenutno; i++) {
//			temp1[i] = _elementi1[i];
//			temp2[i] = _elementi2[i];
//		}
//		delete[] _elementi1; _elementi1 = nullptr;
//		delete[] _elementi2; _elementi2 = nullptr;
//		_elementi1 = temp1;
//		_elementi2 = temp2;
//
//		_elementi1[_trenutno] = elem1;
//		_elementi2[_trenutno++] = elem2;
//
//	}
//
//	T1* getElementi1Pok() { return _elementi1; }
//	T2* getElementi2Pok() { return _elementi2; }
//	T1& getElement1(int lokacija) { return _elementi1[lokacija]; }
//	T2& getElement2(int lokacija) { return _elementi2[lokacija]; }
//	int getTrenutno() { return _trenutno; }
//
//	friend ostream& operator<<(ostream& COUT, Kolekcija<T1, T2>& obj) {
//		for (size_t i = 0; i < obj._trenutno; i++)
//			COUT << obj.getElement1(i) << " " << obj.getElement2(i) << endl;
//		return COUT;
//	}
//};
//class Poglavlje {
//	char* _naslov;
//	char* _sadrzaj;
//	bool _prihvaceno;
//	int _ocjena;//da bi se poglavlje smatralo prihvacenim ocjena mora biti u opsegu od 6 - 10
//public:
//	Poglavlje(const char* naslov = nullptr, const char* sadrzaj = nullptr)
//		:_ocjena(0), _prihvaceno(false) {
//		_naslov = AlocirajNizKaraktera(naslov);
//		_sadrzaj = AlocirajNizKaraktera(sadrzaj);
//	}
//	Poglavlje(const Poglavlje& pogl) {
//		_naslov = AlocirajNizKaraktera(pogl._naslov);
//		_sadrzaj = AlocirajNizKaraktera(pogl._sadrzaj);
//		OcijeniPoglavlje(pogl._ocjena);
//	}
//
//	Poglavlje() {
//		delete[] _naslov; _naslov = nullptr;
//		delete[] _sadrzaj; _sadrzaj = nullptr;
//	}
//	friend ostream& operator<<(ostream& COUT, Poglavlje& obj) {
//		if (obj._naslov == nullptr || obj._sadrzaj == nullptr)
//			return COUT;
//		COUT << endl << obj._naslov << endl << obj._sadrzaj << endl;
//		if (obj._prihvaceno)
//			COUT << "Ocjena: " << obj._ocjena << endl;;
//		return COUT;
//	}
//	char* GetNaslov() { return _naslov; }
//	char* GetSadrzaj() { return _sadrzaj; }
//	bool GetPrihvaceno() { return _prihvaceno; }
//	int GetOcjena() { return _ocjena; }
//
//	void OcijeniPoglavlje(int ocjena) {
//		_ocjena = ocjena;
//		if (_ocjena > 5 && ocjena <= 10)
//			_prihvaceno = true;
//	}
//
//	void SetSadrzaj(string sadrzaj) {
//		char* temp = AlocirajNizKaraktera((sadrzaj + " " + string(_sadrzaj)).c_str());
//		delete[]_sadrzaj;
//		_sadrzaj = temp;
//	}
//
//	void operator=(const Poglavlje& pogl) {
//		if (this != &pogl) {
//			delete[]_naslov;
//			delete[]_sadrzaj;
//			_naslov = AlocirajNizKaraktera(pogl._naslov);
//			_sadrzaj= AlocirajNizKaraktera(pogl._sadrzaj);
//			_prihvaceno = pogl._prihvaceno;
//			OcijeniPoglavlje(pogl._ocjena);
//		}
//
//	}
//};
//
//class ZavrsniRad {
//	char* _tema;
//	vector<Poglavlje> _poglavljaRada;
//	string _datumOdbrane;
//	float _konacnaOcjena; //prosjek ocjena svih poglavlja u zavrsnom radu koja se izracunava u momentu zakazivanja odbrane
//public:
//	ZavrsniRad(const char* nazivTeme = nullptr) : _konacnaOcjena(0), _datumOdbrane(not_set) {
//		_tema = AlocirajNizKaraktera(nazivTeme);
//	}
//
//	ZavrsniRad(const ZavrsniRad& org) : _poglavljaRada(org._poglavljaRada), _konacnaOcjena(org._konacnaOcjena), _datumOdbrane(org._datumOdbrane) {
//		_tema = AlocirajNizKaraktera(org._tema);
//	}
//
//	~ZavrsniRad() {
//		delete[] _tema; _tema = nullptr;
//	}
//	char* GetNazivTeme()const { return _tema; }
//	vector<Poglavlje>& GetPoglavlja() { return _poglavljaRada; };
//	string GetDatumOdbrane()const { return _datumOdbrane; }
//	float GetOcjena() { return _konacnaOcjena; }
//	friend ostream& operator<<(ostream& COUT, ZavrsniRad& obj) {
//		COUT << "Tema rada: " << obj._tema << endl;
//		COUT << "Sadrzaj: " << endl;
//		for (size_t i = 0; i < obj._poglavljaRada.size(); i++)
//			COUT << obj._poglavljaRada[i] << endl;
//		COUT << "Datum odbrane rada: " << obj._datumOdbrane << endl << " Ocjena: " << obj._konacnaOcjena << endl;
//		return COUT;
//	}
//
//
//	void DodajPoglavlje(string naslov, string sadrzaj) {
//		for (vector<Poglavlje>::iterator i = _poglavljaRada.begin(); i != _poglavljaRada.end(); i++)
//		{
//			if (strcmp(i->GetNaslov(), naslov.c_str()) == 0) {
//				i->SetSadrzaj(sadrzaj);
//				return;
//			}
//		}
//
//		_poglavljaRada.push_back(Poglavlje(naslov.c_str(), sadrzaj.c_str()));
//	}
//
//	void OcijeniPoglavlje(string naslov, int ocjena) {
//		for (vector<Poglavlje>::iterator i = _poglavljaRada.begin(); i != _poglavljaRada.end(); i++)
//		{
//			if (strcmp(i->GetNaslov(), naslov.c_str()) == 0) {
//				i->OcijeniPoglavlje(ocjena);
//				return;
//			}
//		}
//	}
//
//	bool operator==(const ZavrsniRad& zr) {
//		return strcmp(_tema, zr._tema) == 0;
//	}
//
//	void operator=(const ZavrsniRad& zr) {
//		if (this != &zr) {
//			delete[]_tema;
//			_tema = AlocirajNizKaraktera(zr._tema);
//			_poglavljaRada = zr._poglavljaRada;
//			_datumOdbrane = zr._datumOdbrane;
//			_konacnaOcjena = zr._konacnaOcjena;
//		}
//	}
//
//	void SetDatum(string dat) { dat = _datumOdbrane; }
//	void SetKonacna(float ocjena) { ocjena = _konacnaOcjena; }
//};
//
//class Osoba {
//protected:
//	string _imePrezime;
//public:
//	Osoba(string imePrezime) : _imePrezime(imePrezime) {}
//	string GetImePrezime() { return _imePrezime; }
//	virtual void Info() = 0;
//
//
//	friend ostream& operator<<(ostream& cout, Osoba& os) {
//		cout << "Ime i prezime: " << os._imePrezime << endl;
//		return cout;
//	}
//};
//
//class Nastavnik:public Osoba {
//	//Parametar string predstavlja broj indeksa studenta koji prijavljuje zavrsni rad kod odredjenog nastavnika
//	Kolekcija<string, ZavrsniRad> _teme;
//public:
//	Kolekcija<string, ZavrsniRad>& GetTeme() { return _teme; };
//
//	Nastavnik(string imePrezime) :Osoba(imePrezime) {};
//
//	friend ostream& operator<<(ostream& cout, Nastavnik& nast) {
//		cout << dynamic_cast<Osoba&>(nast) << endl;
//		cout << "Tema: " << nast._teme << endl;
//		return cout;
//	}
//
//	void Info() {
//		cout << *this << endl;
//	}
//
//	bool DodajZavrsniRad(string indeks, const ZavrsniRad& zr) {
//		try
//		{
//			_teme.AddElement(indeks, zr);
//			return true;
//		}
//		catch (const std::exception& e)
//		{
//			return false;
//		}
//
//		return false;
//	}
//
//
//	ZavrsniRad* ZakaziOdbranuRada(string indeks, string datumOdbrane) {
//		float suma = 0;
//		for (size_t i = 0; i < _teme.getTrenutno(); i++)
//		{
//			if (_teme.getElement1(i) == indeks) {
//				
//				if (_teme.getElement2(i).GetPoglavlja().size() < min_polgavlja) return nullptr;
//
//				for (vector<Poglavlje>::iterator j = _teme.getElement2(i).GetPoglavlja().begin(); j != _teme.getElement2(i).GetPoglavlja().end(); j++)
//				{
//					if (strlen(j->GetSadrzaj()) < min_karaktera_po_poglavlju || !j->GetPrihvaceno())
//						return nullptr;
//					suma += j->GetOcjena();
//				}
//				suma /= _teme.getElement2(i).GetPoglavlja().size();
//				_teme.getElement2(i).SetDatum(datumOdbrane);
//				_teme.getElement2(i).SetKonacna(suma);
//				return &_teme.getElement2(i);
//			}
//
//		}
//		return nullptr;
//	}
//
//};
//
//int main() {
//	const int max = 4;
//	Nastavnik* nastavnici[max];
//
//	nastavnici[0] = new Nastavnik("Denis Music");
//	nastavnici[1] = new Nastavnik("Zanin Vejzovic");
//	nastavnici[2] = new Nastavnik("Jasmin Azemovic");
//	nastavnici[3] = new Nastavnik("Emina Junuz");
//
//
//	ZavrsniRad multimedijalni("Multimedijalni informacijski sistem za visoko - obrazovnu ustanovu");
//	ZavrsniRad podrsa_operaterima("Sistem za podršku rada kablovskog operatera");
//	ZavrsniRad analiza_sigurnosti("Prakticna analiza sigurnosti bežičnih računarskih mreža");
//	ZavrsniRad kriptografija("Primjena teorije informacija u procesu generisanja kriptografskih ključeva");
//
//
//	/*u zavrsni rad dodaje novo poglavlje i njegov sadrzaj. ukoliko poglavlje vec postoji u zavrsnom radu, 
//	funkcija tom poglavlju treba dodati novi sadrzaj i pri tome zadrzi postojeci 
//	(izmedju postojeceg i novog sadrzaja se dodaje prazan prostor). u slucaju da poglavlje ne postoji, ono se dodaje zajedno sa sadrzajem*/
////nazivPoglavlja, sadrzajPoglavlja
//
//	multimedijalni.DodajPoglavlje("Uvod", "U ovom poglavlju ce biti rijeci");
//	multimedijalni.DodajPoglavlje("Uvod", "o multimedijalnim sistemima koji se danas koriste");
//	multimedijalni.DodajPoglavlje("Uvod", "u savremenom poslovanju");
//	multimedijalni.DodajPoglavlje("Vrste multimedijalnih sistema", "Danas se moze govoriti o nekoliko vrsta multimedijalnih sistema, a neke od najznacajnijih su ...");
//	multimedijalni.DodajPoglavlje("Teorija multimedije", "Sadrzaj koji bi trebao stajati na pocetku treceg poglavlja zavrsnog rada o multimediji studenta IB130011");
//
//	//nazivPoglavlja, ocjena
//	multimedijalni.OcijeniPoglavlje("Uvod", 8);
//	multimedijalni.OcijeniPoglavlje("Vrste multimedijalnih sistema", 7);
//	multimedijalni.OcijeniPoglavlje("Teorija multimedije", 10);
////
////
////	/*funkcija DodajZavrsniRad ima zadatak da odredjenom nastavniku dodijeli mentorstvo na zavrsnom radu. zavrsni rad se dodaje studentu sa brojem indeksa proslijedjenim kao prvi parametar.
////	sprijeciti dodavanje zavrsnih radova sa istom temom*/
////	//brojIndeksa, zavrsniRad
//	if (nastavnici[0]->DodajZavrsniRad("IB130011", multimedijalni))
//		cout << "Zavrsni rad uspjesno dodat!" << endl;
//	if (nastavnici[0]->DodajZavrsniRad("IB120051", podrsa_operaterima))
//		cout << "Zavrsni rad uspjesno dodat!" << endl;
//	if (!nastavnici[0]->DodajZavrsniRad("IB120056", podrsa_operaterima))//dupliranje rada
//		cout << "Zavrsni rad nije dodat!" << endl;
//	if (!nastavnici[0]->DodajZavrsniRad("IB120051", kriptografija)) //studentu vec dodijeljen rad
//		cout << "Zavrsni rad nije dodat!" << endl;
//	if (nastavnici[1]->DodajZavrsniRad("IB140102", analiza_sigurnosti))
//		cout << "Zavrsni rad uspjesno dodat!" << endl;
//	if (nastavnici[2]->DodajZavrsniRad("IB140002", kriptografija))
//		cout << "Zavrsni rad uspjesno dodat!" << endl;
//
//	/*funkcija ZakaziOdbranuRada ima zadatak da studentu sa proslijedjenim brojem indeksa zakaze odbranu zavrsnog rada sto podrazumijeva definisanje
//	datuma odbrane. odbrana rada se moze zakazati samo studentu koji je rad prethodno prijavio.
//	Za zakazivanje odbrane rada moraju biti zadovoljeni sljedeci uslovi:
//				   1. zavrsni rad mora imati broj poglavlja veci od minimalnog
//				   2. svako poglavlje mora imati broj karaktera veci od minimalnog
//				   3. svako poglavlje mora biti prihvaceno/odobreno
//	ukoliko su zadovoljeni prethodni kriteriji, izracunava se konacna ocjena rada (prosjek ocjena svih poglavlja), postavlja datum odbrane rada i vraca pokazivac na rad kome je zakazan odbrana.
//	u slucaju da student sa primljenim brojem indeksa nije prijavio zavrsni rad ili neki od postavljenih kriterija nije zadovoljen, funkcija vraca nullptr.
//*/
////
//////brojIndeksa, datumOdbrane
//	ZavrsniRad* zr1 = nastavnici[0]->ZakaziOdbranuRada("IB130011", "25.09.2018");
//	if (zr1 != nullptr)
//		cout << *zr1 << endl;
//
//	zr1 = nastavnici[0]->ZakaziOdbranuRada("IB130111", "25.09.2018");//student sa brojem indeksa IB130111 jos uvijek nije prijavio rad
//	if (zr1 != nullptr)
//		cout << *zr1 << endl;
//
////	//ispisuje sve podatke o nastavniku i njegovim mentorstvima
//	cout << *nastavnici[0] << endl;
////
////	/*Funkcija PronadjiNajStudenta ima zadatak da svim studentima koji su uspjesno okoncali svoj zavrsni rad kod nastavnika/mentora sa najnizom prosjecnom ocjenom
////	i tom prilikom ostvarili ocjenu vecu od proslijedjene, u zasebnom thread.u, posalje email poruku (mail adresa: brojIndeksa@edu.fit.ba) sa sadrzajem, "Postovani {brojIndeksa}, uzimajuci u obzir cinjenicu da ste kod mentora {imePrezimeMentora} uspjesno odbranili rad sa ocjenom {ocjena} cast nam je pozvati vas na dodjelu nagrada za najbolje studente koja ce se odrzatu u na FIT-u 20.09.2018. godine."
////	da su svoj zavrsni rad uspjesno odbranili sa vecom ili manjom ocjenom od prosjecne.
////	funkcija treba da vrati sadrzaj svih poslatih email poruka, a ukoliko niti jedan od nastavnika ne posjeduje evidentirano mentorstvo na zavrsnom radu, funkcija vraca not_set*/
////	cout << "Studenti za dodjelu nagrada: " << PosaljiPozivZaDodjeluNagrada(nastavnici, max, 9.5) << endl;
////
////	/*
////	Koristeci postojeci programski code, demonstrirati i ukratko opisati polimorfizam.
////	*/
//
//	for (int i = 0; i < max; i++)
//	{
//		delete nastavnici[i];
//		nastavnici[i] = nullptr;
//	}
//	system("pause>0");
//	return 0;
//}


//#include <iostream>
//#include <vector>
//#include<sstream>
//#include<regex>
//using namespace std;
//
//const char* crt = "\n-------------------------------------------\n";
//enum OznakaKrvneGrupe { O, A, B, AB };
//const char* OznakaKrvneGrupeString[] = { "O", "A", "B", "AB" };
//
//ostream& operator<<(ostream& cout, const OznakaKrvneGrupe& obj) {
//	if (obj == O)cout << "O";
//	else if (obj == A)cout << "A";
//	else if (obj == B)cout << "B";
//	else if (obj == AB)cout << "AB";
//	return cout;
//}
//
//class Datum {
//	int _dan, _mjesec, _godina;
//public:
//	Datum(int dan, int mjesec, int godina) :
//		_dan(dan), _mjesec(mjesec), _godina(godina) {}
//
//	string ToString(const char* sep = ".")const {
//		stringstream ss;
//		ss<<_dan << sep << _mjesec << sep << _godina << endl;
//		return ss.str();
//	}
//
//};
//
//template <class T1, class T2, int max>
//class Kolekcija {
//	T1 _elementi1[max];
//	T2 _elementi2[max];
//	int _trenutnoElemenata;
//	int _keyElement; // kljucni element, a podrazumijevano T1 predstavlja kljucni element i tada je vrijednost 1, a u slucaju da je T2 onda ce vrijednost biti 2
//public:
//	Kolekcija(int keyElement = 1) {
//		_trenutnoElemenata = 0;
//		_keyElement = keyElement;
//	}
//	bool AddElement(T1 ele1, T2 ele2) {
//		if (_trenutnoElemenata == max)
//			return false;
//		_elementi1[_trenutnoElemenata] = ele1;
//		_elementi2[_trenutnoElemenata] = ele2;
//		_trenutnoElemenata++;
//		return true;
//	}
//
//	void SetElement2(int lokacija, T2 ele2) {
//		_elementi2[lokacija] = ele2;
//	}
//	void SetKeyElement(int keyElement) {
//		if (keyElement < 1 || keyElement>2)
//			throw exception("Nedozvoljena vrijednost!");
//		_keyElement = keyElement;
//	}
//	int GetTrenutno() const { return _trenutnoElemenata; }
//	int GetMax() const { return max; }
//
//	T1 GetElement1(int lokacija) const {
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw exception("Nepostojeca lokacija!");
//		return _elementi1[lokacija];
//	}
//	T2 GetElement2(int lokacija) const {
//		if (lokacija < 0 || lokacija >= _trenutnoElemenata)
//			throw exception("Nepostojeca lokacija!");
//		return _elementi2[lokacija];
//	}
//	friend ostream& operator<<(ostream& COUT, const Kolekcija& obj) {
//		for (size_t i = 0; i < obj.GetTrenutno(); i++)
//			COUT << obj.GetElement1(i) << " " << obj.GetElement2(i) << endl;
//		return COUT;
//	}
//
//	void Sort(string smjer) {
//		bool sort = true;
//		while (sort)
//		{
//				sort = false;
//			for (size_t i = 0; i < _trenutnoElemenata - 1; i++)
//			{
//				if (smjer == "ASC" && _keyElement == 1 && _elementi1[i] > _elementi1[i + 1]) {
//					swap<T1, T2>(_elementi1[i], _elementi1[i + 1]);
//					swap<T1, T2>(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//				else if (smjer == "ASC" && _keyElement == 2 && _elementi2[i] > _elementi2[i + 1]) {
//					swap<T1, T2>(_elementi1[i], _elementi1[i + 1]);
//					swap<T1, T2>(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//				else if (smjer == "DESC" && _keyElement == 1 && _elementi1[i] < _elementi1[i + 1]) {
//					swap<T1, T2>(_elementi1[i], _elementi1[i + 1]);
//					swap<T1, T2>(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//				else if (smjer == "DESC" && _keyElement == 2 && _elementi2[i] < _elementi2[i + 1]) {
//					swap<T1, T2>(_elementi1[i], _elementi1[i + 1]);
//					swap<T1, T2>(_elementi2[i], _elementi2[i + 1]);
//					sort = true;
//				}
//			}
//		}
//	}
//};
//
//class KrvnaGrupa {
//	/*postoje 4 krvne grupe koje su navedene u enumeracije OznakaKrvneGrupe, pri cemu svaka od navedenih moze imati pozitivan (+) i negativan (-) Rh faktor*/
//	OznakaKrvneGrupe _oznaka;//npr: AB
//	char _rhFaktor; // + ili -
//					/*prethodno pomenuto je izuzetno bitno iz razloga sto postoje jasna pravila vezana za darivanje krvi tj. koji primalac moze primiti krv od kojeg donatora sto je prikazano u tabeli, a naredna dva vector-a su zaduzena da cuvaju informacije o tome, npr. za krvnu grupu A+ vector donatori ce cuvati vrijednosti: A+ i AB+ */
//	vector<KrvnaGrupa> _donatori; //krvne grupe kojima odredjena krvna grupa moze donirati krv.
//	vector<KrvnaGrupa> _primaoci; //krvne grupe od kojih odredjena krvna grupa moze primiti krv.
//public:
//	KrvnaGrupa(OznakaKrvneGrupe oznaka, char rhFaktor) :
//		_oznaka(oznaka), _rhFaktor(rhFaktor) {}
//	void SetDonatori(vector<KrvnaGrupa> donatori) {
//		_donatori = donatori;
//	}
//	void SetPrimaoci(vector<KrvnaGrupa> primaoci) {
//		_primaoci = primaoci;
//	}
//
//	string ToString()const {
//		stringstream ss;
//		ss << crt;
//
//			ss << "Krvna grupa: " << _oznaka << _rhFaktor;
//		ss << crt;
//		ss << "Donatori: ";
//		for (vector<KrvnaGrupa>::const_iterator i = _donatori.begin(); i != _donatori.end(); i++)
//		{
//			ss << i->_oznaka << i->_rhFaktor<<",";
//		}
//		ss << crt;
//		ss << "Primaoci: ";
//		for (vector<KrvnaGrupa>::const_iterator i = _primaoci.begin(); i != _primaoci.end(); i++)
//		{
//			ss << i->_oznaka << i->_rhFaktor << ",";
//		}
//		ss << crt;
//
//		return ss.str();
//	}
//
//	bool operator ==(const KrvnaGrupa& kg) {
//		if (_oznaka == kg._oznaka && _rhFaktor == kg._rhFaktor) return true;
//		return false;
//	}
//};
//
////Klasu proglasiti apstraktnom
//class Osoba {
//protected:
//	char* _imePrezime;
//	KrvnaGrupa _krvnaGrupa;
//public:
//	Osoba(const char* imePrezime, KrvnaGrupa krvnaGrupa) : _krvnaGrupa(krvnaGrupa) {
//		int size = strlen(imePrezime) + 1;
//		_imePrezime = new char[size];
//		strcpy_s(_imePrezime, size, imePrezime);
//	}
//
//	Osoba(const Osoba& os) :_krvnaGrupa(os._krvnaGrupa) {
//		int size = strlen(os._imePrezime) + 1;
//		_imePrezime = new char[size];
//		strcpy_s(_imePrezime, size, os._imePrezime);
//	}
//
//	virtual ~Osoba() {
//		delete[] _imePrezime;
//		_imePrezime = nullptr;
//	}
//
//	 KrvnaGrupa GetKrvnaGrupa(){ return _krvnaGrupa; }
//
//	 bool operator==(const Osoba& os) {
//		 return strcmp(_imePrezime, os._imePrezime) == 0;
//	 }
//
//	 friend ostream& operator <<(ostream& o, const Osoba& osoba) {
//		 o << osoba._imePrezime << osoba._krvnaGrupa.ToString() << endl;
//		 return o;
//	 }
//};
//
//
//
//class Donator : public Osoba {
//	//u slucaju da broj telefona nije u validnom formatu potrebno ga je postaviti na podrazumijevanu vrijednost: 000-000-000
//	string _telefon; //regex: 000/000-000 ili 000-000-000
//	Datum _datumPosljednjegDoniranja;
//	bool _podsjetiMe;
//	bool _kontaktirajMe;
//	bool ValidanFormat(string telefon) {
//		if (regex_match(telefon, regex("(\\d{3})([/-])(\\d{3})([-])(\\d{3})"))) return true;
//		return false;
//	}
//
//public:
//	Donator(const char* imePrezime, KrvnaGrupa krvnaGrupa, string telefon, Datum dpd, bool remind = true, bool contact = true)
//		: Osoba(imePrezime, krvnaGrupa), _datumPosljednjegDoniranja(dpd) {
//		if (ValidanFormat(telefon))
//			_telefon = telefon;
//		else
//			_telefon = "000-000-000";
//	}
//
//	Donator(const Donator &don):Osoba(don),_datumPosljednjegDoniranja(don._datumPosljednjegDoniranja),_telefon(don._telefon),
//		_podsjetiMe(don._podsjetiMe),_kontaktirajMe(don._kontaktirajMe){}
//
//	void SetDatum(Datum dat) {
//		dat = _datumPosljednjegDoniranja;
//	}
//
//	friend ostream& operator<<(ostream& o, const Donator& d) {
//		o << "Telefon -> " << d._telefon << endl;
//		o << "Datum posljednjeg doniranja-> " << d._datumPosljednjegDoniranja.ToString() << endl;
//		return o;
//	}
//
//};
//
//class Zahtjev {
//	string _ustanova;
//	Datum _datumZahtjeva;
//	KrvnaGrupa _krvnaGrupa;
//	double _kolicina;
//public:
//	Zahtjev(string ustanova, Datum datum, KrvnaGrupa krvnaGrupa, double kolicina) :
//		_ustanova(ustanova), _datumZahtjeva(datum), _krvnaGrupa(krvnaGrupa), _kolicina(kolicina) { }
//
//	friend ostream& operator<<(ostream& COUT, const Zahtjev& obj) {
//		COUT << "Ustanova: " << obj._ustanova << endl;
//		COUT << "Datum: " << obj._datumZahtjeva.ToString() << endl;
//		COUT << "Krvna grupa: " << obj._krvnaGrupa.ToString() << endl;
//		COUT << "Kolicina: " << obj._kolicina << endl;
//		return COUT;
//	}
//};
//
//class TransfuzijskiCentar {
//	//stanje zaliha za svaku pojedinu krvnu grupu
//	Kolekcija<KrvnaGrupa*, double, 8> _zalihe;
//	//evidentira svaku donaciju krvi
//	Kolekcija<Osoba*, double, 100> _donacije;
//	vector<Zahtjev> _zahtjevi;
//public:
//
//	bool AddDonaciju(Datum dat, Osoba* os, double kolicina) {
//		bool postojiKrvnaGrupa = false;
//		for (size_t i = 0; i < _zalihe.GetTrenutno(); i++)
//		{
//			if (*_zalihe.GetElement1(i) == os->GetKrvnaGrupa()) {
//				_zalihe.SetElement2(i, _zalihe.GetElement2(i)+ kolicina);
//				postojiKrvnaGrupa = true;
//			}
//		}
//		if (!postojiKrvnaGrupa) {
//			_zalihe.AddElement(new KrvnaGrupa(os->GetKrvnaGrupa()), kolicina);
//		}
//
//
//		Donator* don = dynamic_cast<Donator*>(os);
//		for (size_t i = 0; i < _donacije.GetTrenutno(); i++)
//		{
//			if (*_donacije.GetElement1(i) == *os) {
//				dynamic_cast<Donator*>(_donacije.GetElement1(i))->SetDatum(dat);
//				_donacije.SetElement2(i, _donacije.GetElement2(i) + kolicina);
//				return true;
//			}
//		}
//		_donacije.AddElement(new Donator(*don), kolicina);
//		return true;
//	}
//
//	void GetZahvalniceZahvalnice(int redniBroj) {
//		Kolekcija<Osoba*, double, 100> donatoriKolicinaTemp(_donacije);
//		donatoriKolicinaTemp.SetKeyElement(2);
//		//donatoriKolicinaTemp.Sort("DESC");
//		if (redniBroj > donatoriKolicinaTemp.GetTrenutno())
//			throw exception("Ne postoji toliko donatora na spisku.");
//		cout << "Top " << redniBroj << " donatora su: " << endl;
//		for (size_t i = 0; i < redniBroj; i++)
//		{
//			cout << "Donator : ";
//			cout << *dynamic_cast<Donator*>(donatoriKolicinaTemp.GetElement1(i));
//			cout << endl << "Donirana Kolicina: " << donatoriKolicinaTemp.GetElement2(i) << endl;
//		}
//	}
//
//	~TransfuzijskiCentar() {
//		for (size_t i = 0; i < _zalihe.GetTrenutno(); i++)
//			delete _zalihe.GetElement1(i);
//		for (size_t i = 0; i < _donacije.GetTrenutno(); i++)
//			delete _donacije.GetElement1(i);
//	}
//};
//
//void main() {
//
//	/**************************************************************************
//	1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR
//	2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR CE BITI OZNACENO KAO "RE"
//	3. SPASAVAJTE PROJEKAT KAKO BI SE SPRIJECILO GUBLJENJE URADJENOG ZADATKA
//	4. PROGRAMSKI CODE SE TAKODJER NALAZI U FAJLU code.TXT
//	5. NAZIVI FUNKCIJA MORAJU BITI IDENTIÈNI ONIMA KOJI SU KORIŠTENI U TESTNOM CODE-U.OSTALE, POMOÆNE FUNKCIJE MOŽETE IMENOVATI PO ŽELJI. TAKOÐER, MOŽETE DODAVATI KOLIKO ŽELITE TESTNIH PODATAKA
//	****************************************************************************/
//	Datum dat_12_01_2018(12, 1, 2018), dat_01_02_2018(1, 2, 2018);
//	cout << dat_01_02_2018.ToString() << endl; //podrazumijevani separator je tacka ".", pa ispisuje 1.2.2018
//	cout << dat_12_01_2018.ToString("/") << endl; //separator je proslijedjen, pa ispisuje 12/1/2018
//
//	Kolekcija<int, int, 10> kolekcija1;
//	for (size_t i = 0; i < kolekcija1.GetMax(); i++)
//		if (!kolekcija1.AddElement(i, 170000 + i))
//			cout << "Elementi " << i << " i " << 170000 + i << " nisu dodati u kolekciju" << endl;
//
//	cout << kolekcija1.GetElement1(0) << " " << kolekcija1.GetElement2(0) << endl;
//
//	kolekcija1.Sort("ASC"); //kljucne rijeci za sortiranje su ASC i DESC, a sortiranje se vrsi prema kljucnom elementu
//	cout << kolekcija1 << endl << endl << endl;
//	kolekcija1.Sort("DESC");
//	cout << kolekcija1 << endl;
//
//	kolekcija1.SetKeyElement(2);//postavlja kljucni element na T2
//
//	kolekcija1.Sort("DESC"); //sada se sortiranje vrsi po elementu T2
//	cout << kolekcija1 << endl;
//
//	KrvnaGrupa
//		O_poz(O, '+'), O_neg(O, '-'),
//		A_poz(A, '+'), A_neg(A, '-'),
//		B_poz(B, '+'), B_neg(B, '-'),
//		AB_poz(AB, '+'), AB_neg(AB, '-');
//
//	vector<KrvnaGrupa> donori_O_poz{ O_poz, A_poz, B_poz, AB_poz };
//	O_poz.SetDonatori(donori_O_poz);
//	//ili krace napisano
//	O_poz.SetPrimaoci(vector<KrvnaGrupa>{O_poz, O_neg});
//	A_poz.SetDonatori(vector<KrvnaGrupa>{A_poz, AB_poz});
//	A_poz.SetPrimaoci(vector<KrvnaGrupa>{O_poz, A_poz, O_neg, A_neg});
//
//	B_poz.SetDonatori(vector<KrvnaGrupa>{B_poz, AB_poz});
//	B_poz.SetPrimaoci(vector<KrvnaGrupa>{O_poz, B_poz, O_neg, B_neg});
//	/*
//	//Ispis podataka o krvnoj grupi treba biti u formatu:
//	//-------------------------------------------
//	//Krvna grupa -> 0+
//	//-------------------------------------------
//	//Donori  ->  0+, A+, B+, AB+
//	//Primaoci ->	0+, 0-
//	//-------------------------------------------
//	//*/
//	cout << O_poz.ToString() << endl;
//
//	Osoba* jasmin = new Donator("Jasmin Azemovic", B_poz, "061-111-222", Datum(12, 2, 2017), true, true);
//	Osoba* adel = new Donator("Adel Handzic", A_neg, "061-222-333", Datum(9, 1, 2017), true, true);
//	Osoba* goran = new Donator("Goran Skondric", B_neg, "061-333-444", Datum(9, 3, 2017), true, true);
//
//
//	TransfuzijskiCentar tcMostar;
//	/*
//	prilikom svake donacije je potrebno povecati zalihe za tu krvnu grupu
//	ukoliko krvna grupa vec postoji na zalihi onda se uvecava samo njena kolicina
//	takodjer, donatoru se postavlja nova vrijednost datuma posljednje donacije
//	*/
//	////datum donacije, donator, kolicina
//	tcMostar.AddDonaciju(Datum(20, 5, 2017), jasmin, 2.5);
//	tcMostar.AddDonaciju(Datum(20, 5, 2017), adel, 3);
//	tcMostar.AddDonaciju(Datum(6, 5, 2017), goran, 1.2);
//
//
//	tcMostar.AddDonaciju(Datum(10, 9, 2017), jasmin, 2);
//	tcMostar.AddDonaciju(Datum(18, 10, 2017), adel, 1.8);
//	tcMostar.AddDonaciju(Datum(15, 9, 2017), goran, 3.8);
//
//	Zahtjev zahtjev_0_poz("Tranfuziologija KCUS", Datum(18, 2, 2018), O_poz, 15),
//		zahtjev_0_neg("Tranfuziologija Bakir Nakas", Datum(20, 2, 2018), O_neg, 8);
//
//	///*ukoliko transfuzijski centar posjeduje zahtijevane kolicine na stanju, odmah ce ih ustupiti prema zahtjevu,
//	//a u slucaju da ne posjeduje onda ce (koristeci multithreading) kontaktirati (poslati SMS poruku sa odgovarajucim sadrzajem)
//	//sve donore koji zadovoljavaju sljedece uslove:
//	//- mogu donirati krv zahtijevanoj krvnoj grupi
//	//- oznacili su da zele biti kontaktirani
//	//- nisu davali krv u posljednja 3 mjeseca
//	//*/
//	//tcMostar.DodajZahtjev(zahtjev_0_poz);
//	//tcMostar.DodajZahtjev(zahtjev_0_neg);
//
//	////printa zahvalnice (zahvaljujemo se ime i prezime donatoru na ukupno doniranih X doza krvi) za TOP 2 donatora krvi
//	tcMostar.GetZahvalniceZahvalnice(2);
//
//	delete adel;
//	delete jasmin;
//	delete goran;
//}











































